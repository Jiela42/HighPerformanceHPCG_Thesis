AMGX,,128x128x128,SymGS
"ID","Process ID","Process Name","Host Name","Kernel Name","Context","Stream","Block Size","Grid Size","Device","CC","Section Name","Metric Name","Metric Unit","Metric Value","Rule Name","Rule Type","Rule Description"
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.16",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","83110",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.94",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.94",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","79.55",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","33.69",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.42",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","73252",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.69",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.15",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","1.02",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","29.13",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.17",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","29.13",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","844.64",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.48",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.94",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.77",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","43.83",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","20.07",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 2,280,770 sectors to be read from DRAM, which is 1.4x of the 1,627,048 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","29.14",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.29",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","70.86",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.47",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.47 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","49.66",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.12",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","18.92",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.10",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.2 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.0% of the total average of 49.7 cycles between issuing two instructions."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 18.9 threads being active per cycle. This is further reduced to 18.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","21144.35",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","9134360",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","21339.88",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","9218830",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 753255 fused and 585865 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.43",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.88",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1360624",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.47",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","387.48",
"0","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 582426 excessive sectors (21% of the total 2729435 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.16",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","82659",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.22",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.22",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","79.36",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","33.36",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.66",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","73942.04",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.82",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.14",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","1.02",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","28.85",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.15",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","28.85",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","846.84",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.63",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.22",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.71",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","43.76",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","20.17",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 2,282,998 sectors to be read from DRAM, which is 1.4x of the 1,626,665 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","29.34",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.29",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","70.66",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.58",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.58 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","49.68",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.14",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","18.92",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.10",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 49.7 cycles between issuing two instructions."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 18.9 threads being active per cycle. This is further reduced to 18.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","21135.69",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","9130616",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","21331.44",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","9215182",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 752931 fused and 585613 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.19",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.72",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1360048",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.47",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","387.31",
"1","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 581548 excessive sectors (21% of the total 2727686 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.16",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.05",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","78319",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.09",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.09",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","74.72",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.82",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.58",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","69017.58",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.08",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.13",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.99",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","28.45",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.14",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","28.45",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","849.60",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.85",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.09",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.70",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.91",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.54",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 2,141,532 sectors to be read from DRAM, which is 1.4x of the 1,520,778 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","28.60",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.29",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","71.40",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.35",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.35 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.16",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.67",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.00",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.17",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.3% of the total average of 50.2 cycles between issuing two instructions."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.0 threads being active per cycle. This is further reduced to 18.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19441.35",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","8398664",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19638.45",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","8483810",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 689589 fused and 536347 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.53",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.30",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1247440",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.42",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","354.73",
"2","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 536782 excessive sectors (21% of the total 2506653 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","77695",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.46",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.46",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","75.68",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.84",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.37",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","68888.27",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.27",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.13",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","1.00",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","28.48",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.14",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","28.48",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","837.94",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.20",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.46",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.66",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","43.16",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.68",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 2,132,704 sectors to be read from DRAM, which is 1.4x of the 1,514,503 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","28.53",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.29",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","71.47",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.36",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.36 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.33",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.84",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","18.99",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.17",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.0% of the total average of 50.3 cycles between issuing two instructions."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.0 threads being active per cycle. This is further reduced to 18.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19424.50",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","8391384",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19620.79",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","8476182",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 688959 fused and 535857 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.59",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.34",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1246320",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.42",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","354.40",
"3","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 533650 excessive sectors (21% of the total 2501226 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","71846",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.51",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.51",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","69.34",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.21",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.36",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","63350.72",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.72",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.11",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.98",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","28.02",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.12",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","28.02",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","846.21",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.71",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.51",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.41",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.21",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.18",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,979,656 sectors to be read from DRAM, which is 1.4x of the 1,397,572 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","28.20",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","71.80",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.26",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.26 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.55",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","51.12",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.07",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.26",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.6% of the total average of 50.6 cycles between issuing two instructions."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","17554.91",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","7583720",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17751.09",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7668473",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 619065 fused and 481495 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.47",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.62",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1122064",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.35",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","318.45",
"4","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 481171 excessive sectors (21% of the total 2250126 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","71463",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.00",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.00",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","69.31",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.97",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","61.11",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","64054.43",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.95",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.99",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.82",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.11",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.82",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","849.51",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.11",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.00",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.45",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.03",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.36",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,985,034 sectors to be read from DRAM, which is 1.4x of the 1,401,048 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","28.01",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","71.99",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.12",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.12 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.40",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.96",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.07",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.25",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 50.4 cycles between issuing two instructions."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","17626.41",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","7614608",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17822.61",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7699369",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 621738 fused and 483574 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","87.90",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.26",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (87.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1126816",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.36",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","319.82",
"5","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 482859 excessive sectors (21% of the total 2259071 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","70587",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.78",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.78",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","68.51",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.98",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.25",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","61188.75",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.21",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.91",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.12",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.91",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","830.65",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.09",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.78",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.34",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.01",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.75",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,914,548 sectors to be read from DRAM, which is 1.4x of the 1,350,796 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.98",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.02",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.36",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.36 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","51.32",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","51.92",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.11",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.29",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 41.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.4% of the total average of 51.3 cycles between issuing two instructions."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","16884.20",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","7293976",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17080.43",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7378747",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 593991 fused and 461993 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.53",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.30",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1077488",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.33",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","305.55",
"6","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 460063 excessive sectors (21% of the total 2157722 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","70734",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.62",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.62",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","68.61",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.04",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.26",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","60996.15",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.13",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.11",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.95",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.97",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.12",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.97",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","829.14",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.04",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.62",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.37",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.80",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.69",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,913,482 sectors to be read from DRAM, which is 1.4x of the 1,350,599 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","28.12",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","71.88",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.33",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.33 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.97",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","51.57",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.11",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.29",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 41.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 51.0 cycles between issuing two instructions."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","16863.02",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","7284824",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17059.32",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7369628",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 593199 fused and 461377 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.47",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.26",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1076080",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.33",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","305.14",
"7","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 463450 excessive sectors (21% of the total 2158923 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","65742",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.53",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.53",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","63.62",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.64",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.64",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","58578.91",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.69",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.98",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.70",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.11",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.70",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","859.25",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.00",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.53",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.15",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.42",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.08",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,837,170 sectors to be read from DRAM, which is 1.4x of the 1,296,597 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.70",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.30",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.40",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.40 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","51.99",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.63",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.15",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.34",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.2 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 52.0 cycles between issuing two instructions."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","16027.17",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6923736",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","16223.66",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7008622",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 561951 fused and 437073 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.47",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.90",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1020528",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.29",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","289.07",
"8","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 436883 excessive sectors (21% of the total 2043639 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","65573",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.57",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.57",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","64.22",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.40",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.95",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","58824.49",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.67",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.97",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.49",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.49",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","848.93",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.92",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.57",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.15",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.65",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.07",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,834,684 sectors to be read from DRAM, which is 1.4x of the 1,291,604 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.49",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.51",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.44",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.44 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.51",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.15",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.16",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.34",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 41.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 79.8% of the total average of 52.5 cycles between issuing two instructions."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15972.76",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6900232",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","16168.97",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6984994",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 559917 fused and 435491 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.39",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.85",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1016912",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.28",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","288.02",
"9","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 435618 excessive sectors (21% of the total 2036591 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","65130",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.61",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.61",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","62.72",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.40",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.60",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","57270.51",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.22",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.52",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.52",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","849.57",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.11",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.61",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.24",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.29",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.69",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,790,592 sectors to be read from DRAM, which is 1.4x of the 1,263,743 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.60",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.40",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.39",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.39 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.14",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.80",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.18",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.37",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.1% of the total average of 52.1 cycles between issuing two instructions."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15564.46",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6723848",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15761.12",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6808806",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 544653 fused and 423619 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.78",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.46",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","989776",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.26",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","280.17",
"10","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 423857 excessive sectors (21% of the total 1981534 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","64795",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.78",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.78",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","63.26",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.36",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.35",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","57209.21",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.31",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.51",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.51",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","841.23",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.09",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.78",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.23",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.19",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.76",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,781,966 sectors to be read from DRAM, which is 1.4x of the 1,255,884 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.66",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.34",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.45",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.45 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.22",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.89",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.18",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.37",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 52.2 cycles between issuing two instructions."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15539.19",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6712928",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15736.80",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6798296",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 543708 fused and 422884 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.64",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.37",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","988096",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.26",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","279.69",
"11","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 421593 excessive sectors (21% of the total 1976630 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63556",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.02",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.02",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.57",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.14",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.71",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","56728.31",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.41",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.33",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.33",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","850.67",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.20",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.02",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.52",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.99",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.83",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,755,682 sectors to be read from DRAM, which is 1.4x of the 1,237,196 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.59",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.41",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.35",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.35 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.00",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.67",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 82.0% of the total average of 52.0 cycles between issuing two instructions."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15306.63",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6612464",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15502.95",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6697273",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 535014 fused and 416122 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.97",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.58",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","972640",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.25",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","275.21",
"12","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 416286 excessive sectors (21% of the total 1946409 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63594",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.89",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.89",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.98",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.25",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.40",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","56354.49",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.33",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.44",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.44",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","843.32",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.02",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.89",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.51",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.02",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.76",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,749,936 sectors to be read from DRAM, which is 1.4x of the 1,230,278 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.56",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.44",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.40",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.40 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.26",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.93",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.6 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.5% of the total average of 52.3 cycles between issuing two instructions."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15266.67",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6595200",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15463.94",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6680420",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 533520 fused and 414960 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.85",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.50",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","969984",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.25",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","274.44",
"13","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 415480 excessive sectors (21% of the total 1941115 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62704",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.26",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.26",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","60.90",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.35",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.68",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55882.41",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.54",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.97",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.52",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.52",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","852.25",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.12",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.26",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.69",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.69",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.92",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,737,984 sectors to be read from DRAM, which is 1.4x of the 1,226,126 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.59",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.41",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.37",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.37 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.11",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.78",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.1 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.8% of the total average of 52.1 cycles between issuing two instructions."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15183.13",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6559112",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15379.37",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6643886",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 530397 fused and 412531 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.78",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.46",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","964432",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","272.84",
"14","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411565 excessive sectors (21% of the total 1928348 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62996",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.63",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.63",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.44",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.03",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.15",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","56045.24",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.27",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.26",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.26",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","839.20",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.89",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.63",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.68",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.42",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.71",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,727,212 sectors to be read from DRAM, which is 1.4x of the 1,218,868 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.27",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.73",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.44",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.44 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.94",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.63",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.9% of the total average of 52.9 cycles between issuing two instructions."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15080.09",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6514600",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15276.42",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6599412",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 526545 fused and 409535 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.36",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.19",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","957584",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","270.86",
"15","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411210 excessive sectors (21% of the total 1917045 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63254",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.73",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.73",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.82",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.38",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.00",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55709.37",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.28",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.55",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.55",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","838.58",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.89",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.73",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.69",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.75",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.72",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,734,220 sectors to be read from DRAM, which is 1.4x of the 1,224,315 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.58",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.42",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.40",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.40 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.21",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.89",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 52.2 cycles between issuing two instructions."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15149.43",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6544552",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15346.04",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6629489",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 529137 fused and 411551 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.90",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.54",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","962192",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","272.19",
"16","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411653 excessive sectors (21% of the total 1924903 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63202",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.48",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.48",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.25",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.11",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.21",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55849.58",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.17",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.95",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.32",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.32",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","842.51",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.69",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.48",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.63",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.74",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.62",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,726,598 sectors to be read from DRAM, which is 1.4x of the 1,217,156 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.51",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.49",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.43",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.43 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.45",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.14",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.6% of the total average of 52.5 cycles between issuing two instructions."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15064.44",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6507840",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15260.24",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6592422",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 525960 fused and 409080 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.51",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.29",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","956544",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","270.56",
"17","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410016 excessive sectors (21% of the total 1914596 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63069",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.85",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.85",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.63",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.02",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.38",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","56138.19",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.26",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.24",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.24",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","841.34",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.02",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.85",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.40",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.89",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.69",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,738,082 sectors to be read from DRAM, which is 1.4x of the 1,224,232 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.40",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.60",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.41",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.41 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.61",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.29",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.5 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.7% of the total average of 52.6 cycles between issuing two instructions."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15092.61",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6520008",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15289.56",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6605089",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 527013 fused and 409899 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.88",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.52",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","958416",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","271.10",
"18","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410801 excessive sectors (21% of the total 1918843 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62613",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.21",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.21",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.60",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.19",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.80",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55750.20",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.40",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.39",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.39",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","840.78",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.15",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.21",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.39",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.80",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.80",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,732,068 sectors to be read from DRAM, which is 1.4x of the 1,219,951 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.59",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.41",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.48",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.48 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.46",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.15",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.9% of the total average of 52.5 cycles between issuing two instructions."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15071.67",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6510960",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15268.08",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6595812",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 526230 fused and 409290 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.73",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.43",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","957024",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","270.69",
"19","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410261 excessive sectors (21% of the total 1915666 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63898",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.98",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.98",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.41",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.91",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.37",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55877.30",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.76",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.94",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.15",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.15",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","842.26",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.53",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.98",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.14",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.78",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.30",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,728,076 sectors to be read from DRAM, which is 1.4x of the 1,217,333 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.41",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.59",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.38",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.38 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.45",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.14",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.22",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.41",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.5 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.0% of the total average of 52.5 cycles between issuing two instructions."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14974.41",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6468944",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15171.09",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6553909",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 522594 fused and 406462 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.32",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.16",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","950560",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.23",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","268.82",
"20","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 408966 excessive sectors (21% of the total 1904917 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62685",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.91",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.91",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.15",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.96",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.36",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55637.64",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.15",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.95",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.19",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.19",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","843.10",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.01",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.91",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.13",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.76",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.60",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,724,552 sectors to be read from DRAM, which is 1.4x of the 1,211,665 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.32",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.68",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.42",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.42 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.78",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.47",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.23",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.42",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.5 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.5% of the total average of 52.8 cycles between issuing two instructions."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14930.11",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6449808",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15126.67",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6534722",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 520938 fused and 405174 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.93",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.56",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","947616",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.23",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","267.97",
"21","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 406406 excessive sectors (21% of the total 1897593 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63398",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.03",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.03",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","60.96",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.90",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.27",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55229.39",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.67",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.93",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.15",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.15",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","842.37",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.39",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.03",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.94",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.67",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.23",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,714,650 sectors to be read from DRAM, which is 1.4x of the 1,206,731 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.43",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.57",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.43",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.43 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.62",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.32",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.24",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.43",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.4% of the total average of 52.6 cycles between issuing two instructions."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14800.11",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6393648",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14997.21",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6478795",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 516078 fused and 401394 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.82",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.49",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","938976",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.22",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","265.47",
"22","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 402852 excessive sectors (21% of the total 1880754 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.01",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62009",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.06",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.06",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.12",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.92",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.16",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","54911.94",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.09",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.95",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.18",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.18",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","836.67",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.00",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.06",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.93",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.61",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.54",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,704,310 sectors to be read from DRAM, which is 1.4x of the 1,198,831 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.41",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.59",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.43",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.43 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.65",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.35",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.24",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.43",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 52.6 cycles between issuing two instructions."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14727.89",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6362448",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14924.35",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6447320",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 513378 fused and 399294 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.84",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.50",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","934176",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.22",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","264.08",
"23","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 401012 excessive sectors (21% of the total 1871269 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","61792",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.71",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.71",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","59.74",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.93",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.07",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","54161.56",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.86",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.94",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.20",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.20",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","848.30",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.80",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.71",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.86",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.44",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.35",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,691,466 sectors to be read from DRAM, which is 1.4x of the 1,188,955 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.24",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.76",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.40",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.40 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.87",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.59",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.26",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.45",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.7% of the total average of 52.9 cycles between issuing two instructions."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14537.22",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6280080",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14733.74",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6364977",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 506250 fused and 393750 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.52",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.30",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","921504",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.21",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","260.42",
"24","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 397189 excessive sectors (21% of the total 1847999 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","61136",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.12",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.12",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","59.87",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.98",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.49",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","53764.06",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.98",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.95",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.25",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.25",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","842.91",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.97",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.12",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.82",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.39",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.44",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,680,008 sectors to be read from DRAM, which is 1.4x of the 1,181,535 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.00",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.00",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.39",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.39 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","53.30",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","54.02",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.27",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.46",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.5% of the total average of 53.3 cycles between issuing two instructions."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14454.41",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6244304",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14650.10",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6328842",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 503154 fused and 391342 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.65",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.38",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","916000",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.20",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","258.82",
"25","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 393541 excessive sectors (21% of the total 1835812 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","59974",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.19",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.19",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","58.40",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.79",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.78",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","52946.38",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.94",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.94",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.10",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.08",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.10",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","849.17",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.01",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.19",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.75",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.41",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.40",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,655,956 sectors to be read from DRAM, which is 1.4x of the 1,161,303 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.18",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.82",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.28",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.28 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.55",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.28",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.30",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.49",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.6 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 52.5 cycles between issuing two instructions."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14149.87",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6112744",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14346.75",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6197795",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 491769 fused and 382487 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.20",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.09",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","895760",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.18",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","252.97",
"26","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 386063 excessive sectors (21% of the total 1796824 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","58802",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.61",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.61",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","57.50",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.45",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.70",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","52601.41",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.01",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.06",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.95",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.82",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.07",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.82",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","851.55",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.16",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.61",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.73",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.11",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.43",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,639,010 sectors to be read from DRAM, which is 1.4x of the 1,147,262 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.04",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.96",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.28",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.28 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.81",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.55",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.32",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.51",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.8% of the total average of 52.8 cycles between issuing two instructions."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","13912.26",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6010096",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14108.41",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6094831",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 482886 fused and 375578 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.99",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.95",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","879968",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.16",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","248.40",
"27","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 379281 excessive sectors (21% of the total 1765435 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.01",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","57941",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.57",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.57",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","57.06",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.39",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.44",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","50684.41",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.47",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.06",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.93",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.81",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.07",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.81",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","830.42",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.37",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.57",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.73",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","39.71",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.98",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,579,064 sectors to be read from DRAM, which is 1.4x of the 1,108,303 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.84",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.16",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.29",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.29 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","53.23",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","54.01",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.36",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.56",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 43.0 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.8% of the total average of 53.2 cycles between issuing two instructions."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.4 threads being active per cycle. This is further reduced to 18.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","13393.70",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","5786080",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","13589.99",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","5870874",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 463500 fused and 360500 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.41",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.22",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","845504",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.13",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","238.43",
"28","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 365456 excessive sectors (22% of the total 1696886 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","57127",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.51",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.51",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","55.97",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","29.84",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","57.72",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","49365.81",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","22.84",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.04",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.90",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.42",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.06",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.42",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","819.87",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","33.76",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.51",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.55",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","39.43",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.46",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,527,862 sectors to be read from DRAM, which is 1.4x of the 1,069,491 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.65",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.35",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.27",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.27 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","53.54",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","54.36",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.41",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.61",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 43.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.9% of the total average of 53.5 cycles between issuing two instructions."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.4 threads being active per cycle. This is further reduced to 18.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","12843.37",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","5548336",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","13040.87",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","5633657",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 442926 fused and 344498 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.36",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.19",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","808928",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.09",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","227.84",
"29","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 350217 excessive sectors (22% of the total 1623541 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.12",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.01",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","53017",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.56",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.56",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","52.35",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","29.75",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.21",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","46374.91",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.13",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.04",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.91",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.43",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.06",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.43",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","828.44",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.09",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.56",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.58",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","38.64",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.62",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,442,290 sectors to be read from DRAM, which is 1.4x of the 1,009,435 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.68",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.32",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.13",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.13 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.98",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.84",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.49",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.69",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.7% of the total average of 53.0 cycles between issuing two instructions."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.5 threads being active per cycle. This is further reduced to 18.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","12058.07",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","5209088",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","12254.67",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","5294019",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 413568 fused and 321664 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","87.66",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.11",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (87.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","756736",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.02",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","212.74",
"30","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 326349 excessive sectors (22% of the total 1515981 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.12",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.01",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","48489",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.66",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.66",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","48",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","29.17",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.20",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","43041.85",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.19",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.03",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.91",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.11",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.04",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.11",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","841.20",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","33.94",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.66",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.05",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","37.29",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.57",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,324,208 sectors to be read from DRAM, which is 1.4x of the 932,007 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.18",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.26",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.82",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.48",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.48 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","55.32",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","56.31",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.60",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.81",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 45.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 82.1% of the total average of 55.3 cycles between issuing two instructions."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.6 threads being active per cycle. This is further reduced to 18.8 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","11041.43",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","4769896",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","11238.33",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","4854960",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 375561 fused and 292103 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.63",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","58.00",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","689168",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.91",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","193.19",
"31","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 298863 excessive sectors (22% of the total 1380087 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.10",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","994.00",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","43988",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.92",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.92",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","44.22",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","27.98",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","56.64",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","39461.44",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","22.71",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.99",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.89",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","25.29",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.01",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","25.29",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","819.06",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","33.19",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.92",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","17.85",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","35.55",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.06",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,186,284 sectors to be read from DRAM, which is 1.4x of the 826,044 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","25.59",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.26",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","74.41",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.34",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.34 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","56.03",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","57.16",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.76",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.98",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 45.6 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.4% of the total average of 56.0 cycles between issuing two instructions."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.8 threads being active per cycle. This is further reduced to 19.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","9784.76",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","4227016",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","9981.71",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","4312098",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 328581 fused and 255563 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.13",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.04",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","605648",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.75",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","169.02",
"32","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 261526 excessive sectors (22% of the total 1207720 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.10",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","987.35",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","38641",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.41",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.41",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","39.10",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","27.46",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","55.27",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34076.91",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","22.23",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.98",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.87",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","25.19",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.01",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","25.19",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","805.62",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","32.29",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.41",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","17.36",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","33.11",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","16.49",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,031,058 sectors to be read from DRAM, which is 1.4x of the 715,874 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","25.35",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.25",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","74.65",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.07",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.07 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","55.49",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","56.79",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","20.00",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.23",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 45.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.8% of the total average of 55.5 cycles between issuing two instructions."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.0 threads being active per cycle. This is further reduced to 19.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","8386.78",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","3623088",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","8583.82",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","3708211",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 276318 fused and 214914 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","87.84",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.22",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (87.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","512736",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.49",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","142.14",
"33","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 220998 excessive sectors (22% of the total 1017225 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.09",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","980.68",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","32832",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.13",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.13",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","33.44",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","26.80",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","53.08",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","28568.24",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","21.82",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.97",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.85",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","25.05",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.00",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","25.05",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","783.34",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","30.94",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.13",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","17.15",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","28.77",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","15.91",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 854,812 sectors to be read from DRAM, which is 1.4x of the 590,385 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","24.95",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.25",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","75.05",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.72",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.72 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","54.98",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","56.54",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","20.33",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.58",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 43.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 79.5% of the total average of 55.0 cycles between issuing two instructions."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.3 threads being active per cycle. This is further reduced to 19.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","6960.39",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","3006888",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","7157.08",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","3091857",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 222993 fused and 173439 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","86.12",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","55.12",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (86.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","417936",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.10",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","114.71",
"34","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 177590 excessive sectors (22% of the total 820537 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.12",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.01",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","28524",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","51.57",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","51.57",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","28.19",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","24.75",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","46.39",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","24096.19",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","20.07",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.92",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.78",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","23.73",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.95",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","23.73",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","740.92",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","27.74",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","51.57",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.58",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","22.15",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","14.39",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 673,426 sectors to be read from DRAM, which is 1.5x of the 464,194 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","23.56",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.24",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","76.44",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.86",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.86 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","58.84",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","60.87",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","20.71",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.99",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 79.5% of the total average of 58.8 cycles between issuing two instructions."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.7 threads being active per cycle. This is further reduced to 20.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","5527.14",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","2387725",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","5718.12",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","2470229",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 171333 fused and 133259 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","87.15",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","55.77",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (87.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","326096",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","88.13",
"35","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 136389 excessive sectors (22% of the total 630336 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","24781",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","45.90",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","45.90",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","24.22",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.94",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","40.36",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","19090.84",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","18.01",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.90",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.69",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","23.35",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.93",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","23.35",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","666.80",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","25.35",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","45.90",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.27",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","16.54",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","12.81",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","23.33",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.23",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","76.67",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.23",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.57",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.3 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.23 active warps per scheduler, but only an average of 0.57 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","61.01",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","63.61",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","21.08",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.37",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 48.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 79.4% of the total average of 61.0 cycles between issuing two instructions."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.1 threads being active per cycle. This is further reduced to 20.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4274.99",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","1846794",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4457.19",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","1925505",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 128250 fused and 99750 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.86",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.87",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","249504",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","65.97",
"36","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 102203 excessive sectors (22% of the total 472038 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.18",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.06",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18976",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","43.04",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","43.04",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","17.89",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.96",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","37.76",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","14440.16",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","17.54",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.87",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.67",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","23.01",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.92",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","23.01",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","647.84",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","24.92",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","43.04",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","15.96",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","14.46",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","12.33",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","22.81",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.23",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","77.19",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.20",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.58",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.20 active warps per scheduler, but only an average of 0.58 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","57.85",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","60.97",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","21.65",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.98",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 74.2% of the total average of 57.9 cycles between issuing two instructions."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.6 threads being active per cycle. This is further reduced to 21.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3152.83",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","1362024",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3322.89",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","1435490",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 89640 fused and 69720 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","82.76",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","52.97",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (82.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.13",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","180864",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","46.11",
"37","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 71418 excessive sectors (22% of the total 330013 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.18",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.06",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","13452",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","40.96",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","40.96",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","12.67",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","21.54",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","36.27",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","10688.87",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","17.96",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.84",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.67",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","22.56",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.90",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","22.56",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","619.64",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","26.82",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","40.96",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","15.64",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","14.69",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","12.41",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","22.90",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.23",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","77.10",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.72",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.57",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.72 active warps per scheduler, but only an average of 0.57 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","59.92",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","64.12",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","22.52",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.91",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 44.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 74.6% of the total average of 59.9 cycles between issuing two instructions."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.5 threads being active per cycle. This is further reduced to 21.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2253.80",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","973643",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2411.61",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","1041814",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 58707 fused and 45661 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","85.36",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","54.63",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (85.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.13",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","125872",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","30.20",
"38","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 47387 excessive sectors (22% of the total 216800 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.16",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","10779",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","33.52",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","33.52",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","10.37",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","20.55",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","30.16",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","7957.94",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","16.51",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.83",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.61",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","22.34",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.89",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","22.34",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","497.88",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","16.23",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","33.52",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.15",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","15.77",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","11.33",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","22.56",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.23",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","77.44",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","10.16",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.49",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 10.16 active warps per scheduler, but only an average of 0.49 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","45.04",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","48.44",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","23.63",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","23.09",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 29.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 66.0% of the total average of 45.0 cycles between issuing two instructions."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 23.6 threads being active per cycle. This is further reduced to 23.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1652.71",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","713969",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1777.54",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","767898",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 38025 fused and 29575 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 35.4%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","63.58",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","40.69",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (63.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.12",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","89104",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","19.56",
"39","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 30200 excessive sectors (22% of the total 139925 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.18",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.06",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","9459",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","23.34",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","23.34",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","8.90",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.97",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","21.04",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","4920.05",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","13.72",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.98",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.51",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.36",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.05",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.36",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","353.32",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","11.96",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","23.34",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.22",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","15.23",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","9.41",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.39",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.26",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.61",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","10.14",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 10.14 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","38.41",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","41.23",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","25.16",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","24.72",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 19.0 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 49.6% of the total average of 38.4 cycles between issuing two instructions."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1208.03",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","521869",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1296.80",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","560219",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 22725 fused and 17675 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 37.6%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","61.46",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","39.34",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (61.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.12",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","61904",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","11.69",
"40","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 18250 excessive sectors (22% of the total 83865 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.17",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.05",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8899",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","14.75",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","14.75",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","8.45",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","24.32",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.26",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","3395.81",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","11.29",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.42",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","29.56",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.18",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","29.56",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (20.7%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","221.08",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","9.29",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","14.75",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.66",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","15.74",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","7.71",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","30.64",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.31",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","69.36",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.88",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.64",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.3 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.88 active warps per scheduler, but only an average of 0.64 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","32.23",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","34.65",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","26.82",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","26.49",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 12.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 39.6% of the total average of 32.2 cycles between issuing two instructions."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","933.90",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","403445",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1003.94",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","433703",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 13293 fused and 10339 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 37.5%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","61.56",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","39.40",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (61.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.11",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","45136",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","6.84",
"41","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 10693 excessive sectors (22% of the total 49070 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.17",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.06",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8495",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","8.76",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","8.76",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","8",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","24.47",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","8.01",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2597.19",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","9.68",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.17",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.36",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","31.64",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.27",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","31.64",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (23.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","131.63",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","7.48",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","8.76",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.51",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","17.28",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","6.56",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","32.68",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.33",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","67.32",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.87",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.67",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.1 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.87 active warps per scheduler, but only an average of 0.67 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","30.20",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","32.59",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","28.48",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","28.26",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","761.52",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","328978",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","821.77",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","355003",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 7362 fused and 5726 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 37.5%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","61.48",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","39.35",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (61.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.11",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","34592",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","3.79",
"42","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 6050 excessive sectors (22% of the total 27308 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8250",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","6.30",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","4.68",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.90",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.83",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","4.32",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2178.67",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.62",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.21",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","32.63",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.31",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","32.63",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (25.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","69.09",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","6.30",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","6.00",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.20",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","21.03",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.81",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","34.50",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.34",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","65.50",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.85",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.68",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.85 active warps per scheduler, but only an average of 0.68 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","28.56",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","30.92",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","29.92",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","29.79",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 10.0 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.2% of the total average of 28.6 cycles between issuing two instructions."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","656.63",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","283665",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","710.92",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","307118",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 3753 fused and 2919 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 37.6%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","61.47",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","39.34",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (61.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.10",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","28176",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","1.93",
"43","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 3026 excessive sectors (22% of the total 13863 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8076",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.79",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","2.71",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.81",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","21.53",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","2.58",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2171.26",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.19",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.12",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.30",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","30.45",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.22",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","30.45",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (24.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","39.80",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.79",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.62",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.08",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","26.95",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.51",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","35.13",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.35",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","64.87",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.74",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.68",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.74 active warps per scheduler, but only an average of 0.68 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","27.73",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","30.06",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","30.72",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","30.63",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 10.7 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 38.5% of the total average of 27.7 cycles between issuing two instructions."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","610.07",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","263551",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","661.20",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","285639",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 2151 fused and 1673 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 34.8%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","64.17",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","41.07",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (64.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.10",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","25328",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","1.11",
"44","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 1747 excessive sectors (22% of the total 7956 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.16",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.05",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7876",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.46",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","1.20",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.52",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.03",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","1.20",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1863.99",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.94",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.29",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.51",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.51",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (27.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","17.92",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.46",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.37",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.54",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.52",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.33",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","35.61",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","64.39",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.71",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.68",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.71 active warps per scheduler, but only an average of 0.68 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","27.27",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.60",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.39",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.35",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.4 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 41.8% of the total average of 27.3 cycles between issuing two instructions."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","575.54",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","248635",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","624.70",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","269869",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 963 fused and 749 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.6%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.48",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.71",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","23216",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.50",
"45","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 783 excessive sectors (22% of the total 3565 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8051",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.14",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.61",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.78",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.88",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.57",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1809.16",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.58",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.28",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.69",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.69",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (27.9%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","8.99",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.14",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.10",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.10",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","55.15",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.08",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","35.64",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","64.36",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.58",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.69",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.58 active warps per scheduler, but only an average of 0.69 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.87",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.16",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.68",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.66",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.9 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 44.2% of the total average of 26.9 cycles between issuing two instructions."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","561.68",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","242646",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","609.46",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","263287",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 486 fused and 378 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.4%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.59",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.78",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","22368",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.25",
"46","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 421 excessive sectors (23% of the total 1820 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7539",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.39",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.32",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.30",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.93",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.34",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1770.97",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.99",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.25",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.29",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.98",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.36",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.98",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.3%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","4.65",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.39",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.37",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.53",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","67.71",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.35",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","36.09",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","63.91",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.70",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.69",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.70 active warps per scheduler, but only an average of 0.69 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.89",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.17",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.84",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.83",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.8 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 44.0% of the total average of 26.9 cycles between issuing two instructions."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","554.62",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","239595",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","601.80",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","259976",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 243 fused and 189 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.3%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.70",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.85",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","21936",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.12",
"47","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 170 excessive sectors (19% of the total 872 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.12",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.00",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7171",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.60",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.14",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.14",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.62",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.23",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1775.69",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.34",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.65",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.65",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.1%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","2.01",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.60",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.59",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","13.83",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","83.11",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.59",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.8 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","36.00",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","64.00",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.64",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.69",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.64 active warps per scheduler, but only an average of 0.69 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.78",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.07",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.93",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.93",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 12.0 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 44.8% of the total average of 26.8 cycles between issuing two instructions."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","550.43",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","237787",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","597.60",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","258163",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 99 fused and 77 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.5%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.52",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.74",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","21680",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.05",
"48","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 90 excessive sectors (24% of the total 376 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7034",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.70",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.09",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","6.88",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.65",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.22",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1767.43",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.48",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.72",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.72",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","1.32",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.70",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.69",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","15.66",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","86.38",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.69",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","36.02",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","63.98",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.69",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.69",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.69 active warps per scheduler, but only an average of 0.69 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.90",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.18",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.96",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.96",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.8 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 44.0% of the total average of 26.9 cycles between issuing two instructions."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","549.39",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","237335",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","595.99",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","257468",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 63 fused and 49 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 39.0%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.01",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.41",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","21616",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.03",
"49","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 67 excessive sectors (27% of the total 249 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.06",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","952.24",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","6645",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","6.00",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.02",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","6.98",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.75",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.20",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1751.86",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.96",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.25",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.96",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.36",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.96",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.4%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Mbyte/second","220.18",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","6.00",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","6.00",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","13.79",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","94.49",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","6.00",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.5 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","36.29",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","63.71",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.72",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.69",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.72 active warps per scheduler, but only an average of 0.69 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.79",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.10",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.99",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.99",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.9 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 44.6% of the total average of 26.8 cycles between issuing two instructions."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","547.82",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","236657",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","594.94",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","257013",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 9 fused and 7 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.8%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.23",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.55",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","21520",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.00",
"50","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 3 excessive sectors (10% of the total 29 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.06",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","951.82",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","6773",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.89",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.01",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.10",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.73",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.20",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1753.16",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.80",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.25",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.94",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.36",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.94",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.4%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Mbyte/second","144.14",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.89",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.89",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","13.79",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","93.48",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.89",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.5 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","36.37",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","63.63",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.74",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.70",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.74 active warps per scheduler, but only an average of 0.70 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.78",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.10",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.99",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.99",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.7 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 43.8% of the total average of 26.8 cycles between issuing two instructions."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","547.82",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","236657",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","595.09",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","257077",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 9 fused and 7 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.8%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.21",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.53",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","21520",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","77.78",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.00",
"51","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 3 excessive sectors (10% of the total 29 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.08",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","978.05",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7206",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.56",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.10",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.36",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.67",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.37",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1766.50",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.29",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.76",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.76",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","1.32",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.56",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.56",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","15.66",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","48.25",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.55",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","36.03",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","63.97",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.65",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.69",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.65 active warps per scheduler, but only an average of 0.69 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.78",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.06",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.94",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.94",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.7 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 43.8% of the total average of 26.8 cycles between issuing two instructions."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","549.64",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","237443",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","596.44",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","257660",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 84 fused and 61 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.9%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.10",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.46",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","21631",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","81.33",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.03",
"52","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 67 excessive sectors (27% of the total 249 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.08",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","971.27",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7154",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.62",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.14",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.36",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.68",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.23",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1770.30",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.36",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.77",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.77",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","1.97",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.62",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.61",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","13.83",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","81.97",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.60",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.8 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","32.89",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.33",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","67.11",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","10.22",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.63",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 10.22 active warps per scheduler, but only an average of 0.63 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","31.06",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","33.73",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.93",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.92",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 12.0 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 38.5% of the total average of 31.1 cycles between issuing two instructions."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","550.60",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","237859",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","597.86",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","258277",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 113 fused and 85 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.9%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.11",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.47",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","21690",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.44",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.05",
"53","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 90 excessive sectors (24% of the total 376 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7899",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.14",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.30",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.78",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.84",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.40",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1777.61",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.63",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.25",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.28",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.86",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.86",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","4.31",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.14",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.12",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.53",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.73",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.11",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","35.93",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","64.07",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.69",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.69",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.69 active warps per scheduler, but only an average of 0.69 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.98",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.26",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.82",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.81",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.7 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 43.5% of the total average of 27.0 cycles between issuing two instructions."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","554.95",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","239739",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","601.96",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","260047",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 271 fused and 205 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.5%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.49",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.72",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","21956",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.15",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.12",
"54","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 170 excessive sectors (19% of the total 872 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.17",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.05",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8171",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.07",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","0.60",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.78",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.84",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.56",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1812.57",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.47",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.28",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.67",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.67",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (27.9%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","8.91",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.07",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.03",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.09",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","38.13",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.01",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","35.72",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","64.28",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.60",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.69",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.60 active warps per scheduler, but only an average of 0.69 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","26.89",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.18",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.64",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.62",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.6 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 43.2% of the total average of 26.9 cycles between issuing two instructions."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","562.43",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","242970",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","610.35",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","263670",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 549 fused and 414 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.9%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.11",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.47",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","22413",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.31",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.25",
"55","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 421 excessive sectors (23% of the total 1820 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8128",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.28",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","1.16",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.90",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.06",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","1.15",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","1862.39",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.70",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.24",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.28",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.61",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.61",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (27.6%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","17.00",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.28",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.20",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.51",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.77",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.16",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","35.42",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.35",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","64.58",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.71",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.68",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.71 active warps per scheduler, but only an average of 0.68 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","27.41",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.75",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","31.32",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.28",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.3 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 41.1% of the total average of 27.4 cycles between issuing two instructions."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","576.88",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","249211",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","625.93",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","270402",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 1075 fused and 813 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.6%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.46",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.70",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.09",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","23296",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.16",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","0.50",
"56","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 783 excessive sectors (22% of the total 3565 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.16",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8290",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","5.64",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","2.63",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","7.94",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.29",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","2.51",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2007.24",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.02",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.22",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.30",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","33.12",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.32",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","33.12",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (26.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","39.15",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","5.64",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.47",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.09",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","26.93",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.37",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","33.57",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.34",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","66.43",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.97",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.65",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.97 active warps per scheduler, but only an average of 0.65 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","29.69",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","32.17",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","30.55",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","30.47",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 10.7 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.9% of the total average of 29.7 cycles between issuing two instructions."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","613.57",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","265063",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","664.76",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","287176",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 2445 fused and 1841 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.4%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.69",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.84",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.10",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","25538",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.39",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","1.11",
"57","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 1747 excessive sectors (22% of the total 7956 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8370",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","6.21",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","4.60",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","8.06",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.89",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","4.28",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2173.83",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","8.56",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.22",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","32.93",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.32",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","32.93",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (25.7%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","67.73",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","6.21",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","5.91",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.21",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","21.08",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","5.73",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","34.36",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.34",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","65.64",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.84",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.68",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.84 active warps per scheduler, but only an average of 0.68 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","28.63",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","30.98",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","29.71",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","29.58",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 10.3 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.9% of the total average of 28.6 cycles between issuing two instructions."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","661.38",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","285717",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","715.78",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","309216",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 4152 fused and 3147 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.0%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","61.05",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","39.07",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (61.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.10",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","28461",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.05",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","1.93",
"58","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 3026 excessive sectors (22% of the total 13863 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.19",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.07",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8940",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","8.30",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","8.30",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","8.35",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.83",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","7.62",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2783.23",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","9.34",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.11",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","29.96",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.20",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","29.96",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (22.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","126.05",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","7.11",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","8.30",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.51",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","17.21",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","6.24",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","32.84",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.33",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","67.16",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.79",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.67",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.79 active warps per scheduler, but only an average of 0.67 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","29.81",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","32.11",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","28.04",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","27.81",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","774.11",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","334414",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","833.87",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","360233",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 8419 fused and 6330 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 36.1%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","62.85",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","40.23",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (62.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.11",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","35347",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.46",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","3.79",
"59","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 6050 excessive sectors (22% of the total 27308 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.19",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.07",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","9002",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","14.61",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","14.61",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","8.42",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.90",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.11",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","3456.66",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","11.37",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.42",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","29.60",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.18",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","29.60",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (20.6%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","221.87",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","9.18",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","14.61",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.66",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","15.72",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","7.62",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","30.58",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.31",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","69.42",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.80",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.65",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.3 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.80 active warps per scheduler, but only an average of 0.65 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","32.06",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","34.42",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","26.31",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","25.98",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 12.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 39.5% of the total average of 32.1 cycles between issuing two instructions."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","952.82",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","411617",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1023.03",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","441948",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 14882 fused and 11247 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.2%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.80",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.91",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.11",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","46271",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.20",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","6.84",
"60","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 10693 excessive sectors (22% of the total 49070 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.21",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.08",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","9809",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","22.41",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","22.41",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","9.06",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.65",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","20.30",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","4987.47",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","13.55",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.99",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.51",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.62",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.06",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.62",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","347.08",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","11.53",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","22.41",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.21",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","15.21",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","9.08",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.72",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.28",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","9.85",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 9.85 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","35.54",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","38.09",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","24.56",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","24.13",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 18.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 52.5% of the total average of 35.5 cycles between issuing two instructions."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1238.53",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","535045",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1327.42",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","573447",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 25287 fused and 19139 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 38.2%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","60.85",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","38.94",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (60.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.12",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","63734",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.12",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","11.69",
"61","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 18250 excessive sectors (22% of the total 83865 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.21",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.08",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","11267",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","32.12",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","32.12",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","10.40",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","20.01",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","28.89",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","8171.94",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","16.20",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.83",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.60",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","22.31",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.89",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","22.31",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","496.37",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","15.54",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","32.12",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.15",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","15.57",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","10.84",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","22.66",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.23",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","77.34",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","10.09",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.50",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 10.09 active warps per scheduler, but only an average of 0.50 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","44.53",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","47.79",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","23.01",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","22.49",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 29.0 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 65.0% of the total average of 44.5 cycles between issuing two instructions."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 23.0 threads being active per cycle. This is further reduced to 22.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1698.71",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","733841",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1823.11",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","787584",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 41889 fused and 31783 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","LaunchStats","","","","LaunchConfiguration","WRN","A wave of thread blocks is defined as the maximum number of blocks that can be executed in parallel on the target GPU. The number of blocks in a wave depends on the number of multiprocessors and the theoretical occupancy of the kernel. This kernel launch results in 3 full waves and a partial wave of 51 thread blocks. Under the assumption of a uniform execution duration of all thread blocks, the partial wave may account for up to 25.0% of the total kernel runtime with a lower occupancy of 36.3%. Try launching a grid with no partial wave. The overall impact of this tail effect also lessens with the number of full waves executed for a grid. See the Hardware Model (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-hw-model) description for more details on launch configurations."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","62.70",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","40.13",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (62.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.13",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","91864",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.00",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","19.56",
"62","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 30200 excessive sectors (22% of the total 139925 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","13528",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","40.75",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","40.75",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","13.12",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","21.48",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","36.14",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","10733.27",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","18.35",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.86",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.69",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","23.07",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.92",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","23.07",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","598.51",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","26.56",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","40.75",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","15.64",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","14.58",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","12.35",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","23.34",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.23",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","76.66",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.63",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.60",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.3 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.63 active warps per scheduler, but only an average of 0.60 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","58.41",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","62.41",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","21.93",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.33",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 43.1 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 73.8% of the total average of 58.4 cycles between issuing two instructions."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2317.80",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","1001291",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2476.48",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","1069838",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 64083 fused and 48733 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","84.69",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","54.20",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (84.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.13",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","129712",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.88",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","30.20",
"63","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 47387 excessive sectors (22% of the total 216800 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.17",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.05",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","19146",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","42.41",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","42.41",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","18.18",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.44",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","37.46",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","14788.78",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","17.88",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.88",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.68",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","23.11",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.92",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","23.11",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","637.51",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","24.91",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","42.41",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","15.92",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","14.52",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","12.21",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","23.56",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.24",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","76.44",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.14",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.14 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","55.77",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","58.69",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","21.05",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.40",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.0 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 75.3% of the total average of 55.8 cycles between issuing two instructions."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.0 threads being active per cycle. This is further reduced to 20.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3247.25",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","1402812",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3417.44",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","1476333",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 97571 fused and 74252 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","80.35",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","51.43",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (80.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.13",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","186529",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.85",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","46.11",
"64","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 71418 excessive sectors (22% of the total 330013 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.11",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.00",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","24938",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","45.56",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","45.56",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","24.90",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","23.49",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","40.09",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","19456.26",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","18.37",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.90",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.71",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","23.53",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.94",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","23.53",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","648.86",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","25.15",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","45.56",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.28",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","16.64",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","12.72",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","24.08",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.24",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","75.92",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.14",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.14 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","58.71",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","61.12",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","20.51",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.83",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.2 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 78.8% of the total average of 58.7 cycles between issuing two instructions."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.5 threads being active per cycle. This is further reduced to 19.8 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4397.90",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","1899894",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4578.02",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","1977704",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 138575 fused and 105650 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","87.43",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","55.96",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (87.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","256879",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.76",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","65.97",
"65","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 102203 excessive sectors (22% of the total 472038 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.11",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.00",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","28373",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","51.81",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","51.81",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","28.29",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","24.38",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","46.85",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","24464.16",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","20.69",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.93",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.80",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","23.96",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.96",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","23.96",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","737.68",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","27.96",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","51.81",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","16.60",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","22.11",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","14.47",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 674,474 sectors to be read from DRAM, which is 1.5x of the 463,083 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","23.94",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.24",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","76.06",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.77",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.77 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","57.52",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","59.46",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","20.21",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.50",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 45.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 78.8% of the total average of 57.5 cycles between issuing two instructions."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.2 threads being active per cycle. This is further reduced to 19.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","5671.31",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","2450005",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","5862.30",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","2532514",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 183443 fused and 140179 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","85.44",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","54.68",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (85.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","334746",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.64",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","88.13",
"66","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 136389 excessive sectors (22% of the total 630336 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.10",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","991.07",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","33173",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","55.64",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","55.64",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","33.44",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","26.48",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","52.42",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","28957.34",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","22.10",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.98",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.86",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","25.29",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.01",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","25.29",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","783.38",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","30.81",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","55.64",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","17.19",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","28.95",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","15.74",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 855,444 sectors to be read from DRAM, which is 1.4x of the 590,739 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","25.26",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.25",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","74.74",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.54",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.57",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.54 active warps per scheduler, but only an average of 0.57 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","53.61",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","55.09",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.88",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.15",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.2 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 78.8% of the total average of 53.6 cycles between issuing two instructions."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.9 threads being active per cycle. This is further reduced to 19.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","7126.14",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","3078492",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","7323.25",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","3163644",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 236916 fused and 181395 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","84.73",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","54.23",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (84.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","427881",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","78.84",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","114.71",
"67","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 177590 excessive sectors (22% of the total 820537 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.10",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","988.28",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","38517",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.57",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.57",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","38.94",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","27.35",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","55.43",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34257.33",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","22.74",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.00",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.89",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","25.54",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.02",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","25.54",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","808.29",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","32.54",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.57",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","17.36",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","33.22",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","16.55",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,032,724 sectors to be read from DRAM, which is 1.4x of the 714,494 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","25.51",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.26",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","74.49",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.04",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.04 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","55.02",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","56.29",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.62",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.87",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 44.1 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.1% of the total average of 55.0 cycles between issuing two instructions."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.6 threads being active per cycle. This is further reduced to 18.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","8553.69",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","3695196",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","8750.72",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","3780311",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 290339 fused and 222926 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","87.41",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","55.94",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (87.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","522751",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.08",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","142.14",
"68","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 220998 excessive sectors (22% of the total 1017225 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.11",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/usecond","996.48",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","44216",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.63",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.63",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","44.35",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","28.06",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","56.00",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","39381.40",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","22.96",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.01",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.90",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","25.76",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.03",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","25.76",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","816.87",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","32.85",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.63",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","17.87",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","35.33",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","16.96",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,186,426 sectors to be read from DRAM, which is 1.4x of the 826,237 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","25.88",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.26",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","74.12",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.24",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.24 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","55.03",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","56.12",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.45",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.68",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 44.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.8% of the total average of 55.0 cycles between issuing two instructions."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.4 threads being active per cycle. This is further reduced to 18.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","9949.76",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","4298296",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","10146.24",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","4383174",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 342441 fused and 263483 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.93",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.91",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","615548",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.23",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","169.02",
"69","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 261526 excessive sectors (22% of the total 1207720 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","48446",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.61",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.61",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","47.68",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","28.84",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.01",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","43550.12",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.52",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.03",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.92",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.14",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.05",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.14",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","846.42",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.05",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.61",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.07",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","37.40",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.58",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,328,106 sectors to be read from DRAM, which is 1.4x of the 929,675 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.30",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.26",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.70",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.45",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.45 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","54.95",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","55.91",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.36",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.57",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 44.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.7% of the total average of 54.9 cycles between issuing two instructions."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.4 threads being active per cycle. This is further reduced to 18.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","11187.68",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","4833076",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","11383.93",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","4917859",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 387846 fused and 299123 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.37",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.84",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.14",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","697943",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.28",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","193.19",
"70","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 298863 excessive sectors (22% of the total 1380087 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","53420",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.10",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.10",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","52.29",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","29.80",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","57.92",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","46327.91",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.19",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.05",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.91",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.71",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.07",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.71",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","829.45",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","33.80",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.10",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.59",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","38.67",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.49",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,440,552 sectors to be read from DRAM, which is 1.4x of the 1,009,585 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.69",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.31",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","13.98",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 13.98 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.37",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.21",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.30",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.51",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.9% of the total average of 52.4 cycles between issuing two instructions."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","12179.66",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","5261612",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","12376.34",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","5346579",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 423781 fused and 327500 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","87.76",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.16",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (87.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","764031",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.29",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","212.74",
"71","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 326349 excessive sectors (22% of the total 1515981 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","56210",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.40",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.40",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","55.23",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","29.78",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.28",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","49483.13",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.37",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.05",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.92",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.54",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.06",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.54",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","830.80",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.12",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.40",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.54",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","39.42",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.74",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,529,012 sectors to be read from DRAM, which is 1.4x of the 1,070,536 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.81",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.19",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.28",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.28 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","53.25",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","54.06",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.28",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.49",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 43.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 53.2 cycles between issuing two instructions."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","12934.12",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","5587540",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","13130.70",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","5672464",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 450549 fused and 348854 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.59",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.34",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","814373",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.28",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","227.84",
"72","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 350217 excessive sectors (22% of the total 1623541 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","59031",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.48",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.48",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","57.28",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.33",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","57.69",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","50762.09",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.15",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.06",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.91",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.90",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.08",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.90",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","827.19",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","33.58",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.48",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.76",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","39.76",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","17.65",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,575,694 sectors to be read from DRAM, which is 1.4x of the 1,105,253 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","26.80",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","73.20",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.30",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.30 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","53.35",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","54.13",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.27",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.47",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.5 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 79.7% of the total average of 53.4 cycles between issuing two instructions."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","13461.12",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","5815204",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","13656.94",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","5899799",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 469163 fused and 363736 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.75",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.80",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","849549",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.26",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","238.43",
"73","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 365456 excessive sectors (22% of the total 1696886 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","59255",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.15",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.15",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","58.08",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.32",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.15",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","52837.45",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.91",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.06",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.94",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.80",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.07",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.80",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","842.85",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.93",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.15",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.70",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.26",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.29",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,633,792 sectors to be read from DRAM, which is 1.4x of the 1,148,012 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.12",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.88",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.24",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.24 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.52",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.26",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.25",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.45",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.7% of the total average of 52.5 cycles between issuing two instructions."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","13962.18",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6031660",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14158.80",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6116601",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 487079 fused and 377974 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.37",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.55",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (88.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","882963",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.26",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","248.40",
"74","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 379281 excessive sectors (21% of the total 1765435 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","60882",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.33",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.33",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","58.72",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.61",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.45",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","53259.19",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.63",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.93",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","26.99",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.08",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","26.99",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","844.53",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.36",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.33",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.76",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.21",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.12",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,652,114 sectors to be read from DRAM, which is 1.4x of the 1,161,778 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.01",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.99",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.24",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.24 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.72",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.45",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.26",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.45",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.6 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.8% of the total average of 52.7 cycles between issuing two instructions."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14181.12",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6126244",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14377.24",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6210969",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 494394 fused and 383987 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.87",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.88",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","897635",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","252.97",
"75","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 386063 excessive sectors (21% of the total 1796824 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.12",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.00",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","60845",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.34",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.34",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","60.58",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.84",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.47",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","54024.56",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.13",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.95",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.16",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.16",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","833.10",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.14",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.34",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.81",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.36",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.53",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,684,106 sectors to be read from DRAM, which is 1.4x of the 1,180,887 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.20",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.80",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.36",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.36 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.78",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.49",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.24",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.44",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 43.0 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.5% of the total average of 52.8 cycles between issuing two instructions."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14474.32",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6252908",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14670.41",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6337616",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 504827 fused and 392298 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.58",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.33",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","917195",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","258.82",
"76","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 393541 excessive sectors (21% of the total 1835812 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62025",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.57",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.57",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","59.68",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.85",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.98",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","54327.22",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.79",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.94",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.15",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.15",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","850.03",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.70",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.57",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.86",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.48",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.29",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,689,534 sectors to be read from DRAM, which is 1.4x of the 1,190,133 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.18",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.82",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.48",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.48 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","53.27",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.99",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.24",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.44",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.5% of the total average of 53.3 cycles between issuing two instructions."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14550.64",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6285876",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14747.50",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6370918",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 507377 fused and 394394 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.85",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.50",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","922309",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.23",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","260.42",
"77","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 397189 excessive sectors (21% of the total 1847999 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62295",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.76",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.76",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","60.29",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.95",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.12",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","54879.56",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.98",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.95",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.21",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.21",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","848.22",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.84",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.76",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.92",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.65",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.45",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,704,932 sectors to be read from DRAM, which is 1.4x of the 1,200,304 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.42",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.58",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.41",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.41 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.56",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.26",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.23",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.42",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.4% of the total average of 52.6 cycles between issuing two instructions."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14736.47",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6366156",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14933.08",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6451089",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 514099 fused and 399706 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.44",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.88",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","934691",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.23",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","264.08",
"78","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 401012 excessive sectors (21% of the total 1871269 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62970",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.43",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.43",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","60.99",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.79",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.60",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55418.22",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.84",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.94",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.07",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.08",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.07",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","842.34",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.75",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.43",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","18.96",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.67",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.35",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,717,290 sectors to be read from DRAM, which is 1.4x of the 1,208,021 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.22",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.78",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.39",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.39 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.86",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.56",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.23",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.42",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.1% of the total average of 52.9 cycles between issuing two instructions."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14805.36",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6395916",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15002.21",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6480954",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 516519 fused and 401646 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.92",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.55",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","939291",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.23",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","265.47",
"79","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 402852 excessive sectors (21% of the total 1880754 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63295",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.33",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.33",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","60.93",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.17",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.82",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55260.64",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","23.92",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.94",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.38",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.38",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","846.19",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.55",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.33",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.14",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.77",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.42",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,721,876 sectors to be read from DRAM, which is 1.4x of the 1,210,929 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.34",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.66",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.34",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.34 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.47",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.16",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.22",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.41",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.5 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.0% of the total average of 52.5 cycles between issuing two instructions."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14933.69",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6451356",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15130.35",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6536310",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 521239 fused and 405346 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.80",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.47",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","947831",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.23",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","267.97",
"80","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 406406 excessive sectors (21% of the total 1897593 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62512",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.22",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.22",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","60.96",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.02",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.74",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55681.78",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.28",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.25",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.25",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","848.70",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.26",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.22",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.14",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.84",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.71",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,728,182 sectors to be read from DRAM, which is 1.4x of the 1,216,390 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.42",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.58",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.39",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.39 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.47",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.16",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.22",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.41",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.3% of the total average of 52.5 cycles between issuing two instructions."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14976.57",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6469880",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15172.59",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6554557",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 522776 fused and 406566 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.95",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.57",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","950690",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.23",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","268.82",
"81","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 408966 excessive sectors (21% of the total 1904917 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62757",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.08",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.08",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.57",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.16",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.59",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55799.04",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.35",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.37",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.37",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","841.20",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.18",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.08",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.40",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.82",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.77",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,727,784 sectors to be read from DRAM, which is 1.4x of the 1,224,171 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.44",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.56",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.43",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.43 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.59",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.28",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.6% of the total average of 52.6 cycles between issuing two instructions."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15073.33",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6511680",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15270.08",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6596676",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 526370 fused and 409370 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.78",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.46",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","957124",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","270.69",
"82","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410261 excessive sectors (21% of the total 1915666 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63012",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.88",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.88",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.66",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.24",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.45",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55739.05",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.28",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.43",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.43",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","840.51",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.03",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.88",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.40",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.80",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.71",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,736,076 sectors to be read from DRAM, which is 1.4x of the 1,223,036 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.42",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.58",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.36",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.36 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.35",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.03",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.1% of the total average of 52.4 cycles between issuing two instructions."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15093.36",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6520332",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15289.59",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6605103",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 527076 fused and 409935 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.71",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.42",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","958461",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","271.10",
"83","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410801 excessive sectors (21% of the total 1918843 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62924",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.74",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.74",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","60.93",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.20",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.28",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55698.39",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.27",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.40",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.40",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","847.36",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.84",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.74",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.65",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.83",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.70",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,727,350 sectors to be read from DRAM, which is 1.4x of the 1,217,584 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.53",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.47",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.36",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.36 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.17",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.85",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.2% of the total average of 52.2 cycles between issuing two instructions."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15064.86",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6508020",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15261.12",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6592805",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 525995 fused and 409100 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.52",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.29",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","956569",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","270.56",
"84","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410016 excessive sectors (21% of the total 1914596 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63475",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.49",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.49",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","62.27",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.33",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","58.88",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55795.59",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.19",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.50",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.50",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","832.18",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","34.77",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.49",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.69",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.69",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.65",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,734,602 sectors to be read from DRAM, which is 1.4x of the 1,221,292 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.48",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.52",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.37",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.37 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.28",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.96",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.9% of the total average of 52.3 cycles between issuing two instructions."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15149.59",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6544624",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15346.41",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6629648",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 529151 fused and 411559 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.96",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.57",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","962202",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","272.19",
"85","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411653 excessive sectors (21% of the total 1924903 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62720",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.88",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.88",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.47",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.89",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.37",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","56275.19",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.37",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.07",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.15",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.15",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","838.76",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.07",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.88",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.70",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.73",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.79",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,723,984 sectors to be read from DRAM, which is 1.4x of the 1,220,151 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.33",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.67",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.37",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.37 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.57",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.25",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.7% of the total average of 52.6 cycles between issuing two instructions."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15080.09",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6514600",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15276.06",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6599259",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 526545 fused and 409535 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.63",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.36",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","957584",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","270.86",
"86","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411210 excessive sectors (21% of the total 1917045 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","62828",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.19",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.19",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.38",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.36",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.59",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","55853.35",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.50",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.97",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.54",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.54",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","845.55",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.08",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.19",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.69",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.80",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.89",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,731,906 sectors to be read from DRAM, which is 1.4x of the 1,226,066 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.64",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.36",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.35",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.35 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","51.91",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.59",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.6% of the total average of 51.9 cycles between issuing two instructions."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15183.13",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6559112",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15380.23",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6644261",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 530397 fused and 412531 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.27",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.77",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","964432",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.24",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","272.84",
"87","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411565 excessive sectors (21% of the total 1928348 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63540",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.90",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.90",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.60",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.24",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.63",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","56401.70",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.36",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.42",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.42",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","848.59",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.05",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.90",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.52",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","40.66",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.79",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,747,220 sectors to be read from DRAM, which is 1.4x of the 1,229,655 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.52",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.48",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.41",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.41 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.37",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","53.04",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.6 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.3% of the total average of 52.4 cycles between issuing two instructions."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15266.92",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6595308",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15463.78",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6680352",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 533541 fused and 414972 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.52",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.29",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","969999",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.25",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","274.44",
"88","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 415480 excessive sectors (21% of the total 1941115 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.13",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","63332",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.27",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.27",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","61.92",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.24",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.89",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","56536.94",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.50",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.97",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.42",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.42",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","845.85",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.39",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.27",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.51",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.00",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.90",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,757,338 sectors to be read from DRAM, which is 1.4x of the 1,239,270 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.49",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.51",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.38",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.38 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.30",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.97",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.3 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.9% of the total average of 52.3 cycles between issuing two instructions."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15306.71",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6612500",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15503.03",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6697311",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 535021 fused and 416126 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.47",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.26",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","972645",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.25",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","275.21",
"89","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 416286 excessive sectors (21% of the total 1946409 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","64574",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.00",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.00",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","62.66",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.32",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.98",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","57262.64",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.39",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.48",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.48",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","849.41",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.35",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.00",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.23",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.18",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.82",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,788,676 sectors to be read from DRAM, which is 1.4x of the 1,260,225 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.62",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.38",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.42",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.42 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.21",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.87",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.18",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.37",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.0 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.4% of the total average of 52.2 cycles between issuing two instructions."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15539.19",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6712928",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15735.90",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6797909",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 543708 fused and 422884 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.96",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.58",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","988096",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.26",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","279.69",
"90","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 421593 excessive sectors (21% of the total 1976630 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","64746",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.98",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.98",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","62.69",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.12",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.82",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","57769.23",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.35",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.08",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.28",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.09",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.28",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","850.09",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.38",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.98",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.23",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.15",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.80",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,792,502 sectors to be read from DRAM, which is 1.4x of the 1,261,352 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.48",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.52",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.38",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.38 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.31",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.97",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.18",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.37",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.1% of the total average of 52.3 cycles between issuing two instructions."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15564.46",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6723848",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","15760.96",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6808735",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 544653 fused and 423619 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.59",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.34",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","989776",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.26",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","280.17",
"91","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 423857 excessive sectors (21% of the total 1981534 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","65603",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.49",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.49",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","63.87",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.56",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.94",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","58538.81",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.66",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.09",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.97",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.62",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.10",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.62",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","853.63",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.90",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.49",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.14",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.44",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.06",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,834,726 sectors to be read from DRAM, which is 1.4x of the 1,294,155 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.65",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.35",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.45",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.45 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","52.28",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.92",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.16",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.34",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.1 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.6% of the total average of 52.3 cycles between issuing two instructions."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15972.76",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6900232",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","16168.80",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","6984921",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 559917 fused and 435491 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.03",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.62",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1016912",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.28",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","288.02",
"92","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 435618 excessive sectors (21% of the total 2036591 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","65791",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","58.45",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","58.45",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","64.35",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","31.66",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.55",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","58533.75",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.68",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.98",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.72",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.11",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.72",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","849.45",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.77",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","58.45",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.13",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.66",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.07",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,834,910 sectors to be read from DRAM, which is 1.4x of the 1,294,586 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.89",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.11",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.45",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.45 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","51.82",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","52.46",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.15",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.34",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.2 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.4% of the total average of 51.8 cycles between issuing two instructions."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","16027.17",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","6923736",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","16223.85",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7008702",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 561951 fused and 437073 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.04",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.63",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1020528",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.29",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","289.07",
"93","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 436883 excessive sectors (21% of the total 2043639 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","70642",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.65",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.65",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","68.64",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.00",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.40",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","61058.88",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.16",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.94",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.12",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.94",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","829.05",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.01",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.65",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.39",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.78",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.71",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,912,850 sectors to be read from DRAM, which is 1.4x of the 1,351,192 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.92",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.08",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.33",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.33 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","51.31",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","51.90",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.11",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.29",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 41.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.7% of the total average of 51.3 cycles between issuing two instructions."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","16863.02",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","7284824",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17058.91",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7369451",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 593199 fused and 461377 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.63",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.36",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1076080",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.33",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","305.14",
"94","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 463450 excessive sectors (21% of the total 2158923 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.14",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.02",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","70742",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.56",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.56",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","68.99",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.17",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.39",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","60816.16",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.16",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.11",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.96",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","28.09",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.12",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","28.09",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","824.89",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.04",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.56",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.33",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","41.98",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.71",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,915,966 sectors to be read from DRAM, which is 1.4x of the 1,353,016 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.94",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.06",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.33",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.33 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","51.28",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","51.87",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.11",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.29",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 41.5 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.9% of the total average of 51.3 cycles between issuing two instructions."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","16884.20",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","7293976",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17080.98",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7378984",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 593991 fused and 461993 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.85",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.50",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1077488",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.33",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","305.55",
"95","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 460063 excessive sectors (21% of the total 2157722 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.16",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.05",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","72349",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.31",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.31",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","69.15",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.04",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.25",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","63952.36",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.65",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.98",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.87",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.11",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.87",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","851.77",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.63",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.31",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.47",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.15",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.13",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,981,292 sectors to be read from DRAM, which is 1.4x of the 1,400,080 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","27.97",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","72.03",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.09",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.09 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.38",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.94",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.07",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.25",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 81.3% of the total average of 50.4 cycles between issuing two instructions."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","17626.41",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","7614608",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17823.27",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7699653",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 621738 fused and 483574 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.16",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.42",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (88.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1126816",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.36",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","319.82",
"96","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 482859 excessive sectors (21% of the total 2259071 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.16",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","72651",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","56.85",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","56.85",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","69.57",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.08",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","59.50",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","63599.77",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.45",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.97",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","27.91",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.12",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","27.91",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","843.49",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","35.43",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","56.85",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.42",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.25",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","18.97",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 1,974,192 sectors to be read from DRAM, which is 1.4x of the 1,397,366 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","28.14",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","71.86",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.25",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.25 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.62",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","51.19",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.07",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.26",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.8% of the total average of 50.6 cycles between issuing two instructions."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","17554.91",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","7583720",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17751.60",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","7668691",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 619065 fused and 481495 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","88.41",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","56.58",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. The difference between calculated theoretical (98.4%) and measured achieved occupancy (88.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1122064",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.35",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","318.45",
"97","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 481171 excessive sectors (21% of the total 2250126 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.03",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","77766",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.35",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.35",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","75.42",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.81",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.29",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","68938.06",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.24",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.13",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","1.00",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","28.46",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.14",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","28.46",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","840.47",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.14",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.35",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.66",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.95",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.66",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 2,133,500 sectors to be read from DRAM, which is 1.4x of the 1,515,343 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","28.44",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.28",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","71.56",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.37",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.37 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.53",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","51.04",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","18.99",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.17",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.8 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.7% of the total average of 50.5 cycles between issuing two instructions."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.0 threads being active per cycle. This is further reduced to 18.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19424.50",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","8391384",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19620.98",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","8476265",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 688959 fused and 535857 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.42",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.23",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1246320",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.42",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","354.40",
"98","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 533650 excessive sectors (21% of the total 2501226 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","77764",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.51",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.51",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","74.85",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","32.95",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.20",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","68725.97",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.27",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.13",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","1.00",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","28.57",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.14",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","28.57",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","848.86",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.13",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.51",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.69",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","42.99",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","19.68",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 2,141,000 sectors to be read from DRAM, which is 1.4x of the 1,517,739 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","28.71",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.29",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","71.29",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.43",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.55",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.43 active warps per scheduler, but only an average of 0.55 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","50.26",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.76",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","19.00",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.17",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.6 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.8% of the total average of 50.3 cycles between issuing two instructions."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.0 threads being active per cycle. This is further reduced to 18.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19441.35",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","8398664",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19638.03",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","8483627",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 689589 fused and 536347 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","89.75",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.44",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1247440",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.42",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","354.73",
"99","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 536782 excessive sectors (21% of the total 2506653 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","82492",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.30",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.30",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","79.39",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","33.76",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","60.89",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","73068.18",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.87",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.16",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","1.03",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","29.19",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.17",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","29.19",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","846.33",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.71",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.30",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.71",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","43.76",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","20.21",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 2,283,202 sectors to be read from DRAM, which is 1.4x of the 1,628,309 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","29.19",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.29",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","70.81",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.52",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.52 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","49.75",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.21",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","18.92",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.10",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.0 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.3% of the total average of 49.7 cycles between issuing two instructions."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 18.9 threads being active per cycle. This is further reduced to 18.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","21135.69",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","9130616",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","21331.76",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","9215321",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 752931 fused and 585613 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.43",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.88",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1360048",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.47",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","387.31",
"100","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 581548 excessive sectors (21% of the total 2727686 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","1.15",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.04",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","82410",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Memory Throughput","%","57.36",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","DRAM Throughput","%","57.36",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Duration","usecond","79.52",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","33.50",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","L2 Cache Throughput","%","61.09",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","SM Active Cycles","cycle","73630.21",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.91",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 2:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.15",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","1.03",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issue Slots Busy","%","28.98",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.16",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Compute Workload Analysis","SM Busy","%","28.98",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","All compute pipelines are under-utilized. Either this kernel is very small or it doesn't issue enough warps per scheduler. Check the Launch Statistics and Scheduler Statistics sections for further details."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Memory Throughput","Gbyte/second","844.66",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Busy","%","36.89",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Max Bandwidth","%","57.36",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L1/TEX Hit Rate","%","19.79",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Compression Ratio","","0",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","L2 Hit Rate","%","43.80",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Memory Workload Analysis","Mem Pipes Busy","%","20.24",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from device memory causes 2,277,964 sectors to be read from DRAM, which is 1.4x of the 1,629,375 sectors causing a miss in the L2 cache. The DRAM fetch granularity for read misses in L2 is 64 bytes, i.e. the lower or upper half of an L2 cache line. Try changing your access pattern to make use of both sectors returned by a DRAM read request for optimal usage of the DRAM throughput. For strided memory reads, avoid strides of 64 bytes or larger to avoid moving unused sectors from DRAM to L2. "
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","One or More Eligible","%","29.12",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Issued Warp Per Scheduler","","0.29",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","No Eligible","%","70.88",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Active Warps Per Scheduler","warp","14.48",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 16 warps per scheduler, this kernel allocates an average of 14.48 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","49.72",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","50.18",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Active Threads Per Warp","","18.92",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.10",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.2 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 80.8% of the total average of 49.7 cycles between issuing two instructions."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 18.9 threads being active per cycle. This is further reduced to 18.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","21144.35",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Executed Instructions","inst","9134360",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","21341.03",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Instruction Statistics","Issued Instructions","inst","9219325",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","InstructionStats","","","","FPInstructions","WRN","This kernel executes 753255 fused and 585865 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Block Size","","672",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Grid Size","","1024",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Registers Per Thread","register/thread","32",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Shared Memory Configuration Size","Kbyte","16.38",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Threads","thread","688128",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Launch Statistics","Waves Per SM","","3.16",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit SM","block","32",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Registers","block","3",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Shared Mem","block","16",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Block Limit Warps","block","3",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Active Warps per SM","warp","63",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Theoretical Occupancy","%","98.44",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Occupancy","%","90.43",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","Achieved Active Warps Per SM","warp","57.88",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (98.4%) is limited by the number of required registers. This kernel's theoretical occupancy (98.4%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions Ratio","%","0.15",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Instructions","inst","1360624",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Branch Efficiency","%","79.47",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","Source Counters","Avg. Divergent Branches","","387.48",
"101","3238717","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","13","(672, 1, 1)","(1024, 1, 1)","0","8.0","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 582426 excessive sectors (21% of the total 2729435 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
