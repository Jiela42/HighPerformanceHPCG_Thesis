AMGX,RTX3090,128x128x128,SymGS
"ID","Process ID","Process Name","Host Name","Kernel Name","Context","Stream","Block Size","Grid Size","Device","CC","Section Name","Metric Name","Metric Unit","Metric Value","Rule Name","Rule Type","Rule Description"
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.70",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","340'977",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.12",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.12",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","245.57",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.58",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.34",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","323'410.68",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.43",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","85.84",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (85.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (85.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","252.46",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.34",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.12",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.87",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.09",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.35",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.68",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.32",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.66",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.66 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","111.32",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","112.00",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","18.92",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.10",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 49.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.8% of the total average of 111.3 cycles between issuing two instructions."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 18.9 threads being active per cycle. This is further reduced to 18.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","27'848.66",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","9'134'360",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","28'017.65",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","9'189'790",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 753255 fused and 585865 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","80.47",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.63",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'360'624",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.47",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","510.34",
"0","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 582426 excessive sectors (21% of the total 2729435 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.68",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","340'667",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.15",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.15",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","245.82",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.58",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.36",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","323'238.87",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.47",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","85.85",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (85.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (85.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","252.25",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.36",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.15",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.81",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.11",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.36",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.67",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.67 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","111.32",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","111.99",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","18.92",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.10",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 49.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.7% of the total average of 111.3 cycles between issuing two instructions."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 18.9 threads being active per cycle. This is further reduced to 18.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","27'837.24",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","9'130'616",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","28'006.22",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","9'186'040",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 752931 fused and 585613 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","80.44",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.61",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'360'048",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.47",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","510.12",
"1","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 581548 excessive sectors (21% of the total 2727686 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.70",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","311'300",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.56",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.56",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","224.06",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.51",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.48",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","298'142.16",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.66",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.65",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","85.25",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (85.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (85.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","256.73",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.48",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.56",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.66",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","18.50",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.42",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.67",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.33",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.57",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.57 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","110.48",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","111.21",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.00",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.17",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 48.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.0% of the total average of 110.5 cycles between issuing two instructions."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.0 threads being active per cycle. This is further reduced to 18.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","25'605.68",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","8'398'664",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","25'774.66",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","8'454'088",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 689589 fused and 536347 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.66",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.24",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'247'440",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.42",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","467.20",
"2","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 536782 excessive sectors (21% of the total 2506653 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.71",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","310'930",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.52",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.52",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","223.58",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.52",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.46",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","297'809.77",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.69",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.65",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","85.26",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (85.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (85.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","256.67",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.46",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.52",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.60",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","18.50",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.43",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.67",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.33",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.60",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.60 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","110.68",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","111.41",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","18.99",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.17",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 48.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.9% of the total average of 110.7 cycles between issuing two instructions."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.0 threads being active per cycle. This is further reduced to 18.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","25'583.49",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","8'391'384",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","25'752.49",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","8'446'818",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 688959 fused and 535857 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.50",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.16",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'246'320",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.42",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","466.77",
"3","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 533650 excessive sectors (21% of the total 2501226 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","281'174",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.82",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.82",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","203.17",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.47",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.46",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","269'306.68",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.17",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.65",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.72",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.7%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","258.14",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.46",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.82",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.23",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.54",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.26",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.68",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.32",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.54",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.54 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.96",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.76",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.07",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.26",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.4% of the total average of 110.0 cycles between issuing two instructions."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","23'121.10",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","7'583'720",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","23'290.07",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","7'639'144",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 619065 fused and 481495 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.02",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.93",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'122'064",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.35",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","419.42",
"4","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 481171 excessive sectors (21% of the total 2250126 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.66",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","283'382",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.64",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.64",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","204.83",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.48",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.39",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","270'288.50",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.88",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.65",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.78",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","256.42",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.39",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.64",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.27",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.64",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.17",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.67",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.33",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.52",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.52 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.82",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.62",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.07",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.25",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.3% of the total average of 109.8 cycles between issuing two instructions."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","23'215.27",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","7'614'608",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","23'384.27",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","7'670'040",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 621738 fused and 483574 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.28",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.06",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'126'816",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.36",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","421.23",
"5","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 482859 excessive sectors (21% of the total 2259071 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.71",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","267'575",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.16",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.16",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","192.38",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.47",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.59",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","258'653.18",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.84",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.64",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","262.63",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.59",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.16",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.14",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.26",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.48",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.48",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.48 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.03",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.86",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.11",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.29",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.3% of the total average of 109.0 cycles between issuing two instructions."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","22'237.73",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","7'293'976",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","22'406.71",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","7'349'401",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 593991 fused and 461993 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.64",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.75",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'077'488",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.33",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","402.43",
"6","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 460063 excessive sectors (21% of the total 2157722 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.76",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.40",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","268'148",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.08",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.08",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","191.97",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.47",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.55",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","258'374.12",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.56",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.62",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","263.03",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.55",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.08",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.20",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.32",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.39",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.49",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.49 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.21",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.04",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.11",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.29",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.2% of the total average of 109.2 cycles between issuing two instructions."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","22'209.83",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","7'284'824",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","22'378.81",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","7'340'250",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 593199 fused and 461377 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.79",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.82",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'076'080",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.33",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","401.90",
"7","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 463450 excessive sectors (21% of the total 2158923 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","258'519",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.82",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.82",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","186.43",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.48",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.32",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","245'115.10",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.14",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.50",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.5%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.5%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","258.66",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.32",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.82",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.97",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.75",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.93",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.54",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.54 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.77",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.65",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.15",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.34",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 109.8 cycles between issuing two instructions."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","21'108.95",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'923'736",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","21'277.95",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'979'168",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 561951 fused and 437073 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.41",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.12",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'020'528",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.29",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","380.73",
"8","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 436883 excessive sectors (21% of the total 2043639 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.74",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","258'955",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.65",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.65",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","185.82",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.47",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.25",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","244'391.04",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","79.72",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.44",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","258.43",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.25",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.65",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.99",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.82",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.79",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.58",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.58 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","110.13",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","111.02",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.16",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.34",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.4% of the total average of 110.1 cycles between issuing two instructions."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","21'037.29",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'900'232",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","21'206.28",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'955'660",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 559917 fused and 435491 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.47",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.14",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'016'912",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.28",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","379.35",
"9","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 435618 excessive sectors (21% of the total 2036591 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.66",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","246'530",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.25",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.25",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","178.30",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.47",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.54",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","237'891.30",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.46",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.38",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","261.99",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.54",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.25",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.08",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.69",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.35",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.48",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.48 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.07",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.97",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.18",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.37",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 109.1 cycles between issuing two instructions."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","20'499.54",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'723'848",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'668.51",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'779'272",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 544653 fused and 423619 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.88",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.86",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","989'776",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.26",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","369.01",
"10","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 423857 excessive sectors (21% of the total 1981534 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","247'471",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.07",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.07",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","178.40",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.44",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.46",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","237'978.43",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.00",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.67",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.21",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","261.08",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.46",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.07",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.05",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.71",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.21",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.68",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.32",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.54",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.54 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.98",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.89",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.18",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.37",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 110.0 cycles between issuing two instructions."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","20'466.24",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'712'928",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'635.22",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'768'352",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 543708 fused and 422884 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.36",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.09",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","988'096",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.26",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","368.37",
"11","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 421593 excessive sectors (21% of the total 1976630 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.70",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","244'973",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.94",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.94",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","176.38",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.46",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.33",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","234'069.15",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.52",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.24",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.25",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.33",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.94",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.39",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.41",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.05",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.44",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.44 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.59",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.50",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 108.6 cycles between issuing two instructions."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","20'159.95",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'612'464",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'328.93",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'667'889",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 535014 fused and 416122 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.46",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.66",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","972'640",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.25",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","362.48",
"12","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 416286 excessive sectors (21% of the total 1946409 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.68",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","242'870",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.06",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.06",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","175.33",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.41",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","233'569.85",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.99",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.19",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.65",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.41",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.06",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.37",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.45",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.20",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.46",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.46 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.59",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.51",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.2% of the total average of 108.6 cycles between issuing two instructions."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","20'107.32",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'595'200",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'276.29",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'650'623",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 533520 fused and 414960 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.78",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.81",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","969'984",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.25",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","361.46",
"13","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 415480 excessive sectors (21% of the total 1941115 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.76",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.40",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","243'365",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.83",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.83",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","174.21",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.26",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","232'249.30",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.35",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.17",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.76",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.26",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.83",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.56",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.35",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.00",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.51",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.51 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.20",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.12",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 109.2 cycles between issuing two instructions."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'997.29",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'559'112",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'166.26",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'614'533",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 530397 fused and 412531 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.56",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.71",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","964'432",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","359.35",
"14","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411565 excessive sectors (21% of the total 1928348 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","239'802",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.02",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.02",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","172.83",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.46",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.38",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","230'497.45",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.96",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.19",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.69",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.38",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.02",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.56",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.44",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.19",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.50",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.50 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.15",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.08",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 109.2 cycles between issuing two instructions."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'861.59",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'514'600",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'030.57",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'570'028",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 526545 fused and 409535 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.97",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.90",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","957'584",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","356.74",
"15","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411210 excessive sectors (21% of the total 1917045 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.73",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","241'982",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.90",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.90",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","173.79",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.44",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.31",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","231'797.93",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.62",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.13",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.52",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.31",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.90",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.58",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.32",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.08",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.44",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.44 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.62",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.54",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 108.6 cycles between issuing two instructions."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'952.90",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'544'552",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'121.89",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'599'980",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 529137 fused and 411551 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.76",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.80",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","962'192",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","358.49",
"16","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411653 excessive sectors (21% of the total 1924903 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.70",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","240'284",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.95",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.95",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","172.96",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.35",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","230'431.54",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.70",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.12",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.35",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.35",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.95",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.49",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.47",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.11",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.72",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.28",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.46",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.46 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.53",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.46",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 108.5 cycles between issuing two instructions."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'840.98",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'507'840",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'009.95",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'563'263",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 525960 fused and 409080 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.73",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.79",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","956'544",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","356.34",
"17","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410016 excessive sectors (21% of the total 1914596 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","240'024",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.06",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.06",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","173.12",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.43",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.44",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","231'081.02",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.95",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.06",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.87",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.44",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.06",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.23",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.64",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.19",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.48",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.48 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.98",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.91",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 109.0 cycles between issuing two instructions."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'878.07",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'520'008",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'047.05",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'575'433",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 527013 fused and 409899 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.77",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.81",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","958'416",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","357.05",
"18","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410801 excessive sectors (21% of the total 1918843 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","240'281",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.99",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.99",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","173.31",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.46",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.40",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","230'293.88",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.75",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.22",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.27",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.40",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.99",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.22",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.65",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.13",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.45",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.45 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.76",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.69",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 108.8 cycles between issuing two instructions."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'850.49",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'510'960",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'019.47",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'566'385",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 526230 fused and 409290 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.57",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.72",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","957'024",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","356.52",
"19","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410261 excessive sectors (21% of the total 1915666 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","239'292",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.05",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.05",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","172.61",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.43",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","228'943.85",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.52",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.13",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.80",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.43",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.05",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.00",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.49",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.05",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.49",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.49 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.20",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.14",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.22",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.41",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 109.2 cycles between issuing two instructions."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'722.39",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'468'944",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'891.37",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'524'369",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 522594 fused and 406462 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.20",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.02",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","950'560",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.23",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","354.06",
"20","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 408966 excessive sectors (21% of the total 1904917 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.68",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","238'546",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.04",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.04",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","172.22",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.43",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.42",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","228'613.07",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.52",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.98",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.46",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.42",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.04",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.96",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.47",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.05",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.47",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.47 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.84",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.77",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.23",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.42",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 108.8 cycles between issuing two instructions."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'664.05",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'449'808",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'833.02",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'505'232",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 520938 fused and 405174 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.19",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.01",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","947'616",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.23",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","352.94",
"21","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 406406 excessive sectors (21% of the total 1897593 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.73",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","235'802",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.21",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.21",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","169.31",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.43",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.48",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","226'556.20",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.69",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.96",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","263.51",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.48",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.21",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.80",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.49",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.10",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.45",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.45 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.61",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.55",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.24",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.43",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 108.6 cycles between issuing two instructions."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'492.83",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'393'648",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'661.81",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'449'073",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 516078 fused and 401394 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.62",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.74",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","938'976",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.22",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","349.65",
"22","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 402852 excessive sectors (21% of the total 1880754 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.71",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","235'277",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.08",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.08",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","169.28",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.41",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.45",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","225'623.27",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.46",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.67",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.86",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","261.77",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.45",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.08",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.74",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.58",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.03",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.50",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.50 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.13",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.08",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.24",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.43",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 109.1 cycles between issuing two instructions."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'397.71",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'362'448",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'566.69",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'417'873",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 513378 fused and 399294 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.66",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.76",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","934'176",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.22",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","347.82",
"23","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 401012 excessive sectors (21% of the total 1871269 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.66",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","232'389",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.11",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.11",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","168.06",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.41",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.46",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","222'633.10",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.32",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.81",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.67",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.46",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.11",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.70",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.51",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.99",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.72",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.28",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.48",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.48 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.77",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.73",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.26",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.45",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 108.8 cycles between issuing two instructions."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'146.59",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'280'080",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'315.56",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'335'504",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 506250 fused and 393750 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.65",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.75",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","921'504",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.21",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","342.99",
"24","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 397189 excessive sectors (21% of the total 1847999 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","230'865",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.18",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.18",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","166.40",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.42",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.47",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","221'216.04",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.35",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.83",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","262.23",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.47",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.18",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.65",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.38",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.00",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.45",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.45 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.79",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.76",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.27",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.46",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 108.8 cycles between issuing two instructions."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'037.51",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'244'304",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'206.51",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'299'734",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 503154 fused and 391342 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.37",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.62",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","916'000",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.20",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","340.89",
"25","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 393541 excessive sectors (21% of the total 1835812 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","226'562",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.12",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.12",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","163.71",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.41",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.44",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","216'454.38",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.03",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.74",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.7%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.97",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.44",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.12",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.58",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.37",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.89",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.72",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.28",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.44",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.44 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.27",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.25",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.30",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.49",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.2% of the total average of 108.3 cycles between issuing two instructions."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","18'636.41",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'112'744",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","18'805.39",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'168'168",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 491769 fused and 382487 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.43",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.65",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","895'760",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.18",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","333.18",
"26","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 386063 excessive sectors (21% of the total 1796824 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.68",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","221'555",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.36",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.36",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","159.87",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.42",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.52",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","212'665.27",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.36",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.70",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.69",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.7%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","263.53",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.52",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.36",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.53",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.11",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.00",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.46",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.46 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.57",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.57",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.32",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.51",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 108.6 cycles between issuing two instructions."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","18'323.46",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'010'096",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","18'492.45",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'065'522",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 482886 fused and 375578 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.70",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.78",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","879'968",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.16",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","327.16",
"27","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 379281 excessive sectors (21% of the total 1765435 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.63",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","215'038",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.11",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.11",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","155.94",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.37",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.37",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","205'154.49",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","79.47",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.27",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.03",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.37",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.11",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.55",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.98",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.71",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.47",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.47 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.67",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.71",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.36",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.56",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 108.7 cycles between issuing two instructions."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.4 threads being active per cycle. This is further reduced to 18.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","17'640.49",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","5'786'080",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17'809.49",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","5'841'514",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 463500 fused and 360500 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.71",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.78",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","845'504",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.13",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","314.02",
"28","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 365456 excessive sectors (22% of the total 1696886 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","206'268",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.14",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.14",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","149.09",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.43",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.38",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","195'479.55",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","79.17",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 62% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.35",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.74",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.51",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.5%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.5%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","261.09",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.38",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.14",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.34",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.88",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.61",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.75",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.25",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.48",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.48 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.32",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.40",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.41",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.61",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.6% of the total average of 108.3 cycles between issuing two instructions."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.4 threads being active per cycle. This is further reduced to 18.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","16'915.66",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","5'548'336",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17'084.64",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","5'603'761",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 442926 fused and 344498 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.88",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.86",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","808'928",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.09",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","300.09",
"29","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 350217 excessive sectors (22% of the total 1623541 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.73",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","196'508",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.82",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.82",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","141.12",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.26",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.09",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","185'380.16",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","77.62",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 61% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","82.22",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (82.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (82.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","259.85",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.09",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.82",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.36",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.14",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.11",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.46",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.46 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.85",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.00",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.49",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.69",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.6% of the total average of 108.8 cycles between issuing two instructions."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.5 threads being active per cycle. This is further reduced to 18.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","15'881.37",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","5'209'088",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","16'050.36",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","5'264'519",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 413568 fused and 321664 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.88",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.86",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","756'736",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.02",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","280.20",
"30","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 326349 excessive sectors (22% of the total 1515981 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","176'628",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.40",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.40",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","127.33",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.29",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.32",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","168'699.76",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","78.41",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 62% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.72",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","82.05",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (82.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (82.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","264.29",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.32",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.40",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.87",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.87",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.37",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.75",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.25",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.50",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.50 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.49",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.76",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.60",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.81",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 45.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.0% of the total average of 108.5 cycles between issuing two instructions."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.6 threads being active per cycle. This is further reduced to 18.8 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14'542.37",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","4'769'896",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14'711.35",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","4'825'324",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 375561 fused and 292103 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.71",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.78",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","689'168",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.91",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","254.45",
"31","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 298863 excessive sectors (22% of the total 1380087 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.62",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","154'669",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.54",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.54",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","112.35",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.37",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.34",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","147'757.20",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","78.34",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 62% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.35",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.84",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","81.96",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (82.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (82.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","263.56",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.34",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.54",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.69",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.62",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.35",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.86",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.14",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.38",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.3 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.38 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","105.92",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","107.31",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.76",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.98",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 44.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 41.9% of the total average of 105.9 cycles between issuing two instructions."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.8 threads being active per cycle. This is further reduced to 19.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","12'887.24",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","4'227'016",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","13'056.24",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","4'282'446",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 328581 fused and 255563 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.32",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.59",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","605'648",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.75",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","222.62",
"32","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 261526 excessive sectors (22% of the total 1207720 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.65",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","129'888",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.94",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.94",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","94.08",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.43",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.47",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","124'857.66",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","78.44",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 62% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.35",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.98",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.36",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","81.57",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (81.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (81.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","268.00",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.47",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.94",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.23",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.21",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.38",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.02",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.98",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.21",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.15",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.1 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.21 active warps per scheduler, but only an average of 0.15 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","102.02",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","103.58",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","20.00",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.23",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 43.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.1% of the total average of 102.0 cycles between issuing two instructions."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.0 threads being active per cycle. This is further reduced to 19.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","11'046",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","3'623'088",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","11'214.96",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","3'678'508",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 276318 fused and 214914 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","76.43",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","36.69",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (76.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","512'736",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.49",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","187.21",
"33","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 220998 excessive sectors (22% of the total 1017225 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.66",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","107'397",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.52",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.52",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","77.66",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.58",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.15",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","101'173.04",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","76.56",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 16% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 60% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.36",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.23",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.37",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","81.23",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (81.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (81.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","264.62",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.15",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.52",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.20",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","13.58",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","24.77",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.30",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.70",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.08",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.15",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.08 active warps per scheduler, but only an average of 0.15 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","97.55",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","99.35",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","20.33",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.58",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.4% of the total average of 97.6 cycles between issuing two instructions."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.3 threads being active per cycle. This is further reduced to 19.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","9'167.34",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","3'006'888",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","9'336.33",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","3'062'315",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 222993 fused and 173439 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","75.04",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","36.02",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (75.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","417'936",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.10",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","151.08",
"34","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 177590 excessive sectors (22% of the total 820537 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.63",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","86'177",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.59",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.59",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","62.53",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.90",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.63",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","77'703.66",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","73.31",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 16% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 58% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.37",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.58",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.38",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","81.27",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (81.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (81.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","255.08",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","13.63",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.59",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.87",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","12.35",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","23.72",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.64",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.36",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.84",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.15",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.84 active warps per scheduler, but only an average of 0.15 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","91.66",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","93.69",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","20.71",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.99",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 41.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 45.3% of the total average of 91.7 cycles between issuing two instructions."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.7 threads being active per cycle. This is further reduced to 20.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","7'279.65",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","2'387'725",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","7'441.11",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","2'440'685",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 171333 fused and 133259 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.07",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.07",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","326'096",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","116.08",
"35","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 136389 excessive sectors (22% of the total 630336 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.56",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","66'387",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.13",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.13",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","48.48",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.02",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.34",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","59'529.43",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","71.25",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 56% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.38",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.71",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.39",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","79.40",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (79.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (79.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","249.11",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","13.34",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.13",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.61",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","11.50",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","23.05",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.79",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.21",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.89",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.16",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.89 active warps per scheduler, but only an average of 0.16 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","90.86",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","93.23",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.08",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.37",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 40.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.4% of the total average of 90.9 cycles between issuing two instructions."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 28.0 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 30.8% of the total average of 90.9 cycles between issuing two instructions."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.1 threads being active per cycle. This is further reduced to 20.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","5'630.47",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'846'794",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","5'777.34",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'894'968",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 128250 fused and 99750 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.59",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.32",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","249'504",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","86.89",
"36","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 102203 excessive sectors (22% of the total 472038 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.44",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","47'077",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.00",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.00",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","34.82",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.13",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.38",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","43'513.10",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","70.22",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 55% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.38",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.85",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.39",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","75.93",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (75.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (75.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","244.82",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.38",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.00",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.33",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","10.91",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.72",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.96",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.04",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.91",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.16",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.91 active warps per scheduler, but only an average of 0.16 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","89.41",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","92.29",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.65",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.98",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 37.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.3% of the total average of 89.4 cycles between issuing two instructions."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 28.9 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 32.3% of the total average of 89.4 cycles between issuing two instructions."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.6 threads being active per cycle. This is further reduced to 21.0 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'152.51",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'362'024",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'286.30",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'405'907",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 89640 fused and 69720 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.46",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.26",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","180'864",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","60.73",
"37","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 71418 excessive sectors (22% of the total 330013 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.06",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.30",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","34'377",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","24.68",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","24.68",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","26.50",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.23",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.47",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","30'860.63",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","62.99",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 50% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.38",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.02",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.40",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","70.11",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (70.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (70.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","214.70",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.47",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","24.68",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.20",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","10.22",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","20.38",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.15",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.85",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.80",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.80 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","86.72",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","90.32",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","22.52",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.91",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 34.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 39.3% of the total average of 86.7 cycles between issuing two instructions."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 29.6 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 34.2% of the total average of 86.7 cycles between issuing two instructions."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 22.5 threads being active per cycle. This is further reduced to 21.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'968.42",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","973'643",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'091.73",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'014'089",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 58707 fused and 45661 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","72.87",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","34.98",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (72.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","125'872",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","39.77",
"38","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 47387 excessive sectors (22% of the total 216800 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.33",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","28'349",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","19.35",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","19.35",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","21.22",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.36",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.54",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","22'380.39",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","49.48",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 11% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 39% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.39",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.25",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.41",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","62.62",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (62.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (62.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","173.32",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","13.54",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","19.35",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.47",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","10.08",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","16.01",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","10.40",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","89.60",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.73",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.18",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 9.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.73 active warps per scheduler, but only an average of 0.18 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","83.95",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","88.44",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","23.63",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","23.09",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 33.4 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 39.8% of the total average of 84.0 cycles between issuing two instructions."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 29.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 34.7% of the total average of 84.0 cycles between issuing two instructions."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 23.6 threads being active per cycle. This is further reduced to 23.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'176.73",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","713'969",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'293.06",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","752'124",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 38025 fused and 29575 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","72.20",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","34.65",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (72.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","89'104",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","25.76",
"39","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 30200 excessive sectors (22% of the total 139925 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.96",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.28",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","21'110",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","15.68",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","15.68",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","16.45",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","15.91",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.79",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","14'721.38",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","39.71",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 8% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.43",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.30",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","11.39",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.46",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","56.89",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (56.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","134.93",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.79",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","15.68",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.67",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","10.76",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","12.85",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","11.75",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.12",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","88.25",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.56",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.21",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 8.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.56 active warps per scheduler, but only an average of 0.21 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","72.87",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","76.78",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","25.16",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","24.72",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 25.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 34.4% of the total average of 72.9 cycles between issuing two instructions."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 24.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 33.9% of the total average of 72.9 cycles between issuing two instructions."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'591.06",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","521'869",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'676.52",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","549'899",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 22725 fused and 17675 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","70.38",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","33.78",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (70.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","61'904",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","15.40",
"40","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 18250 excessive sectors (22% of the total 83865 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.16",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.31",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","19'326",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","9.99",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","9.99",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","14.75",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","19.88",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","6.98",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","9'081.04",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","25.36",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 5% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.54",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.25",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","14.22",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.57",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","53.95",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (54.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","87.90",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","6.98",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","9.99",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.06",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","12.16",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","9.35",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","14.73",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.15",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","85.27",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.26",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.26",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 6.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.26 active warps per scheduler, but only an average of 0.26 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","56.09",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","58.87",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","26.82",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","26.49",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 20.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 36.7% of the total average of 56.1 cycles between issuing two instructions."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'230.02",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","403'445",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'290.94",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","423'428",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 13293 fused and 10339 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","67.72",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","32.51",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (67.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.11",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","45'136",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","9.01",
"41","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 10693 excessive sectors (22% of the total 49070 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.29",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'530",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","7.93",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","5.83",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.95",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","24.83",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","2.99",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","5'911.85",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","14.66",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.68",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.22",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","17.77",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.71",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","45.90",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (45.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","52.04",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","4.52",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","7.93",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.90",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","13.56",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","7.93",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","18.52",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.19",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","81.48",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.94",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.32",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 5.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.94 active warps per scheduler, but only an average of 0.32 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","42.89",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","44.92",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","28.48",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","28.26",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 15.3 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 35.8% of the total average of 42.9 cycles between issuing two instructions."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'002.98",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","328'978",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'050.45",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","344'549",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 7362 fused and 5726 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","65.18",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","31.29",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (65.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.11",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","34'592",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","4.99",
"42","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 6050 excessive sectors (22% of the total 27308 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.28",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'145",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.96",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","3.05",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.66",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","30.97",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","1.66",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","4'076.85",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.63",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 2% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.85",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.19",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","22.21",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.89",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.93",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (33.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","27.17",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.77",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.96",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.59",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.26",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.96",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","23.20",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.23",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","76.80",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.67",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.39",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.3 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.67 active warps per scheduler, but only an average of 0.39 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","33.08",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","34.63",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","29.92",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","29.79",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 10.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 32.3% of the total average of 33.1 cycles between issuing two instructions."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","864.83",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","283'665",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","905.45",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","296'987",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 3753 fused and 2919 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","63.59",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","30.52",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (63.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","28'176",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","2.54",
"43","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 3026 excessive sectors (22% of the total 13863 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.26",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.32",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","17'988",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.52",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","1.77",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.57",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","35.51",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","1.04",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","3'299.06",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","6.52",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.97",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.18",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","25.49",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.02",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","25.49",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (24.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","15.75",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.43",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.52",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.40",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","23.13",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.52",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","27.23",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","72.77",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.51",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.45",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.51 active warps per scheduler, but only an average of 0.45 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","27.57",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","28.85",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","30.72",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","30.63",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","803.51",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","263'551",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","840.83",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","275'792",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 2151 fused and 1673 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","62.01",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","29.76",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (62.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","25'328",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","1.46",
"44","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 1747 excessive sectors (22% of the total 7956 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.19",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.32",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'074",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.11",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.79",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.73",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","41.26",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.57",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'675.16",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","6.11",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.13",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.17",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","29.61",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.18",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","29.61",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (25.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","6.94",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.13",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.11",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.98",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","35.62",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.11",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","31.74",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.32",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","68.26",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.39",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.52",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.39 active warps per scheduler, but only an average of 0.52 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","23.27",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","24.32",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.39",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.35",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","758.03",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","248'635",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","792.15",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","259'826",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 963 fused and 749 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","61.96",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","29.74",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (62.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","23'216",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.65",
"45","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 783 excessive sectors (22% of the total 3565 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.31",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","18'083",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","5.96",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.40",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","13.57",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","44.05",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.38",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'444.17",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","5.96",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.21",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.16",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","31.61",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.26",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","31.61",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (27.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","3.60",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.02",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","5.96",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.70",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","49.63",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","5.96",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","34.12",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.34",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","65.88",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.28",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.56",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.28 active warps per scheduler, but only an average of 0.56 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","21.33",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","22.28",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.68",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.66",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.8 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 31.7% of the total average of 21.3 cycles between issuing two instructions."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","739.77",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","242'646",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","772.59",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","253'408",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 486 fused and 378 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","60.74",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","29.15",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","22'368",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.33",
"46","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 421 excessive sectors (23% of the total 1820 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.16",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.31",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","13'460",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","7.90",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.26",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","10.27",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","45.90",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.37",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'315.29",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.90",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.26",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.22",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","32.94",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.32",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","32.94",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","2.28",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.98",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","7.90",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.84",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","63.32",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","7.90",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","35.52",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","64.48",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.26",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.58",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.26 active warps per scheduler, but only an average of 0.58 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","20.44",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","21.34",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.84",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.83",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 7.0 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 34.1% of the total average of 20.4 cycles between issuing two instructions."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","730.47",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","239'595",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","762.68",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","250'158",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 243 fused and 189 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","60.12",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.86",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'936",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.16",
"47","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 170 excessive sectors (19% of the total 872 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.78",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.25",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8'481",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","12.45",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.18",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","6.75",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.79",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.44",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'253.94",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","12.45",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.29",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.34",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.57",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.57",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","1.52",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","6.25",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","12.45",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","13.83",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","81.28",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","12.45",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.13",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.87",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.15",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.15 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.79",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","20.66",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.93",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.93",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 7.1 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.6% of the total average of 19.8 cycles between issuing two instructions."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","724.96",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","237'787",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","756.75",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","248'214",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 99 fused and 77 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.54",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.58",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (59.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'680",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.07",
"48","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 90 excessive sectors (24% of the total 376 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.34",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.19",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","7'425",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","14.20",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.14",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","6.21",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.99",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.47",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'240.04",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","14.20",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.29",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.39",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.72",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.72",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.3%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","1.11",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","7.12",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","14.20",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.66",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","87.04",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","14.20",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","35.98",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","64.02",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.04",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.58",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.04 active warps per scheduler, but only an average of 0.58 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.57",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","20.43",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.96",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.96",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.9 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.2% of the total average of 19.6 cycles between issuing two instructions."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","723.58",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","237'335",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","755.28",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","247'732",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 63 fused and 49 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","60.15",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.87",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'616",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.04",
"49","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 67 excessive sectors (27% of the total 249 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.14",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.16",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","6'506",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","16.16",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.02",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","5.60",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","47.00",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.46",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'232.85",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","16.16",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.29",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.44",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.73",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.35",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.73",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.4%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","182.86",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","8.08",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","16.16",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","13.79",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","97.61",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","16.16",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.5 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.91",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.37",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.09",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.26",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.61",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.26 active warps per scheduler, but only an average of 0.61 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.68",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","20.54",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.99",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.99",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.9 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.2% of the total average of 19.7 cycles between issuing two instructions."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","721.52",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","236'657",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","753.04",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","246'998",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 9 fused and 7 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.69",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.65",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (59.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'520",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.01",
"50","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 3 excessive sectors (10% of the total 29 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.06",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.15",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","6'499",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","16.18",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.02",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","5.63",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","47.27",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.46",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'220.43",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","16.18",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.30",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.44",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.91",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.36",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.91",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","159.09",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","8.09",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","16.18",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","13.79",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","97.19",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","16.18",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.5 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","37.07",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.37",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","62.93",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.27",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.60",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.27 active warps per scheduler, but only an average of 0.60 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.61",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","20.47",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.99",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.99",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 7.0 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.9% of the total average of 19.6 cycles between issuing two instructions."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","721.52",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","236'657",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","753.04",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","246'998",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 9 fused and 7 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","60.04",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.82",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'520",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","77.78",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.01",
"51","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 3 excessive sectors (10% of the total 29 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.44",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.21",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","8'256",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","12.76",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.12",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","6.82",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.71",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.44",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'253.27",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","12.76",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.29",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.35",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.53",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.53",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Mbyte/second","995.31",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","6.39",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","12.76",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.66",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","82.95",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","12.76",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.33",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.67",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.12",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.12 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.60",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","20.46",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.94",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.94",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 7.0 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 35.9% of the total average of 19.6 cycles between issuing two instructions."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","723.91",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","237'443",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","755.61",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","247'839",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 84 fused and 61 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.35",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.49",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (59.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'631",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","81.33",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.04",
"52","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 67 excessive sectors (27% of the total 249 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","8.84",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.26",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","9'348",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","11.30",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.16",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","7.39",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","46.63",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.40",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'261.44",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","11.30",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.28",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.31",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","33.47",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.34",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","33.47",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (29.1%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","1.39",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","5.67",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","11.30",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","13.83",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","80.71",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","11.30",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","36.13",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","63.87",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.05",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.59",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.05 active warps per scheduler, but only an average of 0.59 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","19.52",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","20.38",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.93",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.92",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 7.1 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 36.2% of the total average of 19.5 cycles between issuing two instructions."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","725.18",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","237'859",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","756.96",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","248'284",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 113 fused and 85 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.57",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.59",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (59.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'690",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.44",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.07",
"53","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 90 excessive sectors (24% of the total 376 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.27",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","14'924",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","7.13",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.23",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","11.23",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","45.43",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.32",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'339.35",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.13",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.25",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.20",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","32.62",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.30",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","32.62",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (28.2%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","2.09",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.59",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","7.13",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.84",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","67.01",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","7.13",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","35.51",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.36",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","64.49",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.28",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.58",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 2.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.28 active warps per scheduler, but only an average of 0.58 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","20.50",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","21.40",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.82",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.81",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.9 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 33.4% of the total average of 20.5 cycles between issuing two instructions."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","730.91",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","239'739",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","763.12",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","250'302",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 271 fused and 205 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.97",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.79",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","21'956",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.15",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.16",
"54","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 170 excessive sectors (19% of the total 872 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.30",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","20'019",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","5.38",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.37",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.04",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","43.69",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.35",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'464.20",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","5.38",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.20",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.15",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","31.39",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.26",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","31.39",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (27.0%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","3.28",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","2.73",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","5.38",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.69",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","48.87",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","5.38",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.7 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","33.49",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.33",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","66.51",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.20",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.54",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.0 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.20 active warps per scheduler, but only an average of 0.54 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","21.49",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","22.45",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.64",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.62",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 6.7 cycles being stalled waiting for an immediate constant cache (IMC) miss. A read from constant memory costs one memory read from device memory only on a cache miss; otherwise, it just costs one read from the constant cache. Immediate constants are encoded into the SASS instruction as 'c[bank][offset]'. Accesses to different addresses by threads within a warp are serialized, thus the cost scales linearly with the number of unique addresses read by all threads within a warp. As such, the constant cache is best when threads in the same warp access only a few distinct locations. If all threads of a warp access the same location, then constant memory can be as fast as a register access.. This stall type represents about 31.4% of the total average of 21.5 cycles between issuing two instructions."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","740.76",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","242'970",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","773.57",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","253'732",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 549 fused and 414 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","60.32",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.95",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (60.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","22'413",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.31",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.33",
"55","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 421 excessive sectors (23% of the total 1820 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.36",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","20'450",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","5.40",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","0.69",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.26",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","40.06",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.63",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","2'755.45",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","5.40",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 0% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","1.10",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.15",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","28.81",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","1.15",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","28.81",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","ALU is the highest-utilized pipeline (24.5%) based on active cycles, taking into account the rates of its different instructions. It executes integer and logic operations. It is well-utilized, but should not be a bottleneck."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","6.22",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","2.77",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","5.40",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.95",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","28.72",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","5.40",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","31.14",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.31",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","68.86",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.25",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.51",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.25 active warps per scheduler, but only an average of 0.51 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","23.28",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","24.33",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","31.32",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","31.28",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","759.79",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","249'211",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","793.90",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","260'400",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 1075 fused and 813 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","59.71",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","28.66",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (59.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.09",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","23'296",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.16",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","0.65",
"56","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 783 excessive sectors (22% of the total 3565 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.43",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.35",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","20'292",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","5.78",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","1.57",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.04",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","34.14",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","0.91",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","3'431.27",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","5.78",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and  close to 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.94",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.16",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","24.64",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.99",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","26.21",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (26.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","14.18",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.04",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","5.78",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.36",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","23.47",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","5.78",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","26.52",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.27",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","73.48",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.40",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.44",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 3.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.40 active warps per scheduler, but only an average of 0.44 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","27.91",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","29.20",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","30.55",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","30.47",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 8.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 30.3% of the total average of 27.9 cycles between issuing two instructions."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","808.12",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","265'063",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","845.42",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","277'298",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 2445 fused and 1841 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","61.01",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","29.29",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (61.0%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","25'538",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.39",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","1.46",
"57","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 1747 excessive sectors (22% of the total 7956 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.34",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.33",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","21'063",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.00",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","2.62",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","15.78",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","29.55",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","1.55",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","4'272.80",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","7.26",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 1% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.82",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.17",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","21.34",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.85",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","35.76",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (35.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","23.52",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.25",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.00",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.61",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.15",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.00",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","22.65",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.23",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","77.35",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.64",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.37",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 4.4 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.64 active warps per scheduler, but only an average of 0.37 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","33.73",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","35.30",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","29.71",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","29.58",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 11.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 33.1% of the total average of 33.7 cycles between issuing two instructions."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","871.09",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","285'717",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","911.67",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","299'028",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 4152 fused and 3147 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","62.46",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","29.98",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (62.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.10",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","28'461",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.05",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","2.54",
"58","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 3026 excessive sectors (22% of the total 13863 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.22",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.32",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","21'264",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","6.91",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","5.09",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","16.13",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","22.95",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","2.74",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","6'395.93",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","14.57",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 3% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.64",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.19",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","16.68",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.67",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","48.41",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (48.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","45.06",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","3.94",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","6.91",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.91",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","13.03",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","6.91",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","17.53",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.18",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","82.47",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","7.84",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.30",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 5.7 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 7.84 active warps per scheduler, but only an average of 0.30 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","44.73",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","46.81",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","28.04",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","27.81",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 16.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 37.0% of the total average of 44.7 cycles between issuing two instructions."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'019.55",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","334'414",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'066.98",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","349'970",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 8419 fused and 6330 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 21% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","63.94",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","30.69",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (63.9%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.11",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","35'347",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.46",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","4.99",
"59","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 6050 excessive sectors (22% of the total 27308 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.04",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.29",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","22'186",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","8.80",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","8.80",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","17.15",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","18.34",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","6.22",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","9'847.07",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","24.70",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 5% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.51",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.23",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","13.36",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.53",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","55.60",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (55.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","76.41",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","6.22",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","8.80",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.06",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","11.89",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","8.14",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","13.96",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.14",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","86.04",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.14",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.25",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 7.2 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.14 active warps per scheduler, but only an average of 0.25 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","58.30",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","61.13",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","26.31",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","25.98",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 21.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 37.6% of the total average of 58.3 cycles between issuing two instructions."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'254.93",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","411'617",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'315.78",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","431'575",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 14882 fused and 11247 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","66.13",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","31.74",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (66.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.11",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","46'271",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.20",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","9.01",
"60","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 10693 excessive sectors (22% of the total 49070 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.10",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.30",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","23'268",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","14.30",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","14.30",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","17.86",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","14.77",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","10.98",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","15'861.83",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","40.01",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 8% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.41",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.28",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","10.82",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.43",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","58.66",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","INF","FP64 is the highest-utilized pipeline (58.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. It is well-utilized, but should not be a bottleneck."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","124.97",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","10.98",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","14.30",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.66",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","10.77",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","12.80",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","11.33",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.11",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","88.67",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.45",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.20",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 8.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.45 active warps per scheduler, but only an average of 0.20 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","74.64",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","78.56",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","24.56",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","24.13",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 26.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 35.0% of the total average of 74.6 cycles between issuing two instructions."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 23.5 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 31.5% of the total average of 74.6 cycles between issuing two instructions."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","1'631.23",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","535'045",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","1'716.79",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","563'107",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 25287 fused and 19139 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","67.56",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","32.43",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (67.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.12",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","63'734",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.12",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","15.40",
"61","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 18250 excessive sectors (22% of the total 83865 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.08",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.30",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","30'491",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","17.94",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","17.94",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","23.49",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.17",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.67",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","24'399.93",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","50.58",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 10% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.37",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.29",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.65",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.39",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","63.18",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (63.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (63.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","156.46",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.67",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","17.94",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.50",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","10.03",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","16.20",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.88",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.10",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.12",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.39",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.17",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.1 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.39 active warps per scheduler, but only an average of 0.17 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","84.90",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","89.33",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","23.01",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","22.49",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 32.5 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 38.3% of the total average of 84.9 cycles between issuing two instructions."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 30.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 35.5% of the total average of 84.9 cycles between issuing two instructions."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 23.0 threads being active per cycle. This is further reduced to 22.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","2'237.32",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","733'841",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","2'354.04",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","772'124",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 41889 fused and 31783 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","68.71",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","32.98",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (68.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","91'864",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.00",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","25.76",
"62","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 30200 excessive sectors (22% of the total 139925 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.53",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.36",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","40'387",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","20.90",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","20.90",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","29.60",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","12.81",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.88",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","34'267.35",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","58.44",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","This kernel exhibits low compute throughput and memory bandwidth utilization relative to the peak performance of this device. Achieved compute throughput and/or memory bandwidth below 60.0% of peak typically indicate latency issues. Look at Scheduler Statistics and Warp State Statistics for potential reasons."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 12% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 47% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.36",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.30",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.27",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.37",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","68.83",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (68.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (68.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","191.23",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.88",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","20.90",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.23",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","10.22",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","18.74",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.47",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.53",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.49",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.16",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.49 active warps per scheduler, but only an average of 0.16 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","89.63",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","93.26",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.93",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","21.33",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 35.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 39.0% of the total average of 89.6 cycles between issuing two instructions."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 28.7 cycles being stalled waiting for a scoreboard dependency on a L1TEX (local, global, surface, texture) operation. Find the instruction producing the data being waited upon to identify the culprit. To reduce the number of cycles waiting on L1TEX data accesses verify the memory access patterns are optimal for the target architecture, attempt to increase cache hit rates by increasing data locality (coalescing), or by changing the cache configuration. Consider moving frequently used data to shared memory.. This stall type represents about 32.0% of the total average of 89.6 cycles between issuing two instructions."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.9 threads being active per cycle. This is further reduced to 21.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","3'052.72",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'001'291",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","3'176.18",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'041'786",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 64083 fused and 48733 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","69.32",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","33.27",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (69.3%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","129'712",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.88",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","39.77",
"63","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 47387 excessive sectors (22% of the total 216800 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.36",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.34",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","53'861",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","23.61",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","23.61",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","40.22",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","12.82",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","11.59",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","47'965.85",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","66.72",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 13% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 54% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.36",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.20",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.37",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","74.87",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (74.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (74.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","212.09",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","11.59",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","23.61",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.33",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","10.95",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","21.40",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.28",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.72",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.40",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.15",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.40 active warps per scheduler, but only an average of 0.15 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","90.53",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","93.37",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","21.05",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","20.40",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 38.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 90.5 cycles between issuing two instructions."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 21.0 threads being active per cycle. This is further reduced to 20.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","4'276.87",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'402'812",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","4'410.79",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'446'739",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 97571 fused and 74252 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","69.42",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","33.32",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (69.4%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.13",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","186'529",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.85",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","60.73",
"64","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 71418 excessive sectors (22% of the total 330013 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.55",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","73'333",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","24.61",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","24.61",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","53.66",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","12.88",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.06",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","64'835.88",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","69.59",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 14% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 56% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.36",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.16",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.37",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","78.68",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (78.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is well-utilized, but might become a bottleneck if more work is added. Based on the number of executed instructions, the highest utilized pipeline (78.7%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","225.53",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.06",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","24.61",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.65",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","11.60",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","22.33",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.26",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.74",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.33",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.15",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.8 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.33 active warps per scheduler, but only an average of 0.15 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","89.98",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","92.26",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","20.51",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.83",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 41.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 46.1% of the total average of 90.0 cycles between issuing two instructions."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.5 threads being active per cycle. This is further reduced to 19.8 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","5'792.36",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","1'899'894",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","5'939.29",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","1'948'086",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 138575 fused and 105650 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","69.15",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","33.19",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (69.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","256'879",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.76",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","86.89",
"65","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 102203 excessive sectors (22% of the total 472038 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.55",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","91'903",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","25.87",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","25.87",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","67.26",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","12.88",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","12.79",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","83'866.15",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","73.51",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","INF","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 59% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.36",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","9.10",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.36",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","80.53",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (80.5%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (80.5%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","237.04",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","12.79",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","25.87",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","15.93",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","12.92",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","23.61",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.16",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.84",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.29",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.15",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 10.9 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.29 active warps per scheduler, but only an average of 0.15 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, reduce the time the active warps are stalled by inspecting the top stall reasons on the Warp State Statistics and Source Counters sections."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","90.52",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","92.48",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","20.21",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.50",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 42.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 47.4% of the total average of 90.5 cycles between issuing two instructions."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 20.2 threads being active per cycle. This is further reduced to 19.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","7'469.53",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","2'450'005",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","7'630.96",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","2'502'956",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 183443 fused and 140179 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","68.64",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","32.94",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (68.6%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","334'746",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.64",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","116.08",
"66","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 136389 excessive sectors (22% of the total 630336 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.59",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.37",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","114'741",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","26.56",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","26.56",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","83.55",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","12.89",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.23",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","106'607.77",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","76.05",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 15% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 61% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.35",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.96",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.36",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","81.83",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (81.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (81.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","244.61",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","13.23",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","26.56",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.30",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","13.71",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","24.45",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","9.01",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","90.99",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.56",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.1 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.56 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","94.99",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","96.70",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.88",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","19.15",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 44.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 46.3% of the total average of 95.0 cycles between issuing two instructions."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.9 threads being active per cycle. This is further reduced to 19.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","9'385.65",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","3'078'492",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","9'554.62",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","3'133'915",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 236916 fused and 181395 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","70.81",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","33.99",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (70.8%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","427'881",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","78.84",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","151.08",
"67","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 177590 excessive sectors (22% of the total 820537 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.62",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","137'406",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.25",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.25",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","99.74",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","12.88",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.66",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","130'272.84",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","77.85",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 16% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 62% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.35",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.78",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","82.08",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (82.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (82.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","251.76",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","13.66",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.25",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.37",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.40",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.06",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.83",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.17",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","8.84",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.3 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 8.84 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","100.07",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","101.57",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.62",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.87",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 44.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.6% of the total average of 100.1 cycles between issuing two instructions."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.6 threads being active per cycle. This is further reduced to 18.9 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","11'265.84",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","3'695'196",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","11'434.80",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","3'750'616",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 290339 fused and 222926 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","73.08",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","35.08",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (73.1%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","522'751",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.08",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","187.21",
"68","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 220998 excessive sectors (22% of the total 1017225 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.76",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.40",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","161'607",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.34",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.34",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","115.71",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","12.87",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.72",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","153'409.74",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","78.09",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 16% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 62% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.65",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","82.21",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (82.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (82.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","256.07",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","13.72",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.34",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.80",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.61",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.15",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.08",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.08 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","104.38",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","105.73",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.45",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.68",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 45.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.3% of the total average of 104.4 cycles between issuing two instructions."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.4 threads being active per cycle. This is further reduced to 18.7 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","13'104.56",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","4'298'296",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","13'273.56",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","4'353'729",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 342441 fused and 263483 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","75.17",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","36.08",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (75.2%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","615'548",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.23",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","222.62",
"69","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 261526 excessive sectors (22% of the total 1207720 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.72",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","181'439",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.65",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.65",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","130.46",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","12.98",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.93",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","172'804.74",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","78.78",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 16% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 62% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.62",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.34",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","82.68",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (82.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (82.7%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","257.92",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","13.93",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.65",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","16.98",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","14.88",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.40",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.65",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.35",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.20",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.20 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","106.36",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","107.58",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.36",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.57",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.4% of the total average of 106.4 cycles between issuing two instructions."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.4 threads being active per cycle. This is further reduced to 18.6 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","14'734.99",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","4'833'076",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","14'903.99",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","4'888'510",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 387846 fused and 299123 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","76.75",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","36.84",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (76.7%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.14",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","697'943",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.28",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","254.45",
"70","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 298863 excessive sectors (22% of the total 1380087 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.73",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","200'079",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.27",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.27",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","143.74",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.08",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","13.81",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","188'023.93",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","78.07",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 16% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 62% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.32",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.62",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.34",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.04",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","254.61",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","13.81",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.27",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.42",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.25",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.19",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.65",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.35",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.23",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.6 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.23 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","106.72",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","107.85",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.30",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.51",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.8% of the total average of 106.7 cycles between issuing two instructions."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","16'041.50",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","5'261'612",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","16'210.52",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","5'317'051",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 423781 fused and 327500 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","76.51",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","36.72",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (76.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","764'031",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.29",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","280.20",
"71","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 326349 excessive sectors (22% of the total 1515981 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","208'753",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.75",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.75",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","150.88",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.23",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.21",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","198'401.78",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","79.54",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.67",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.67",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.7%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","257.55",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.21",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.75",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.37",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.06",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.69",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.32",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.32 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","107.01",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","108.07",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.28",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.49",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.3% of the total average of 107.0 cycles between issuing two instructions."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","17'035.18",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","5'587'540",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17'204.18",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","5'642'970",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 450549 fused and 348854 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","77.46",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.18",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. The difference between calculated theoretical (87.5%) and measured achieved occupancy (77.5%) can be the result of warp scheduling overheads or workload imbalances during the kernel execution. Load imbalances can occur between warps within a block as well as across blocks of the same kernel. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","814'373",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.28",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","300.09",
"72","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 350217 excessive sectors (22% of the total 1623541 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","217'320",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.84",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.84",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","156.93",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.28",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.22",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","206'574.48",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","79.59",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.69",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.7%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.7%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","258.53",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.22",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.84",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.57",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","15.99",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.72",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.67",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.33",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.36",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.36 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","107.96",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","108.99",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.27",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.47",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.1 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.6% of the total average of 108.0 cycles between issuing two instructions."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","17'729.28",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","5'815'204",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","17'898.53",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","5'870'717",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 469163 fused and 363736 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","77.97",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.43",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","849'549",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.26",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","314.02",
"73","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 365456 excessive sectors (22% of the total 1696886 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.68",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","223'303",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.12",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.12",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","161.09",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.34",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.40",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","213'928.65",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.41",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.90",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","261.44",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.40",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.12",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.56",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.15",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.99",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.41",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.41 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.28",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.28",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.25",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.45",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.4% of the total average of 108.3 cycles between issuing two instructions."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","18'389.21",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'031'660",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","18'558.73",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'087'262",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 487079 fused and 377974 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.24",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.55",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","882'963",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.26",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","327.16",
"74","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 379281 excessive sectors (21% of the total 1765435 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.72",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","228'071",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.92",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.92",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","163.97",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.37",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.34",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","217'114.87",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","79.92",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.92",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.47",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.34",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.92",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.61",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.36",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.84",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.43",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.43 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.37",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.36",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.26",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.45",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.4% of the total average of 108.4 cycles between issuing two instructions."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.3 threads being active per cycle. This is further reduced to 18.5 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","18'677.57",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'126'244",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","18'847.04",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'181'830",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 494394 fused and 383987 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.62",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.74",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","897'635",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","333.18",
"75","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 386063 excessive sectors (21% of the total 1796824 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.64",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","231'263",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.10",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.10",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","167.55",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.39",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.45",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","221'632.33",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.48",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.95",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.09",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.45",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.10",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.64",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.42",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.03",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.45",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.45 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.83",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.80",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.24",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.44",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 108.8 cycles between issuing two instructions."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'063.74",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'252'908",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'233.04",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'308'437",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 504827 fused and 392298 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.65",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.75",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","917'195",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","340.89",
"76","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 393541 excessive sectors (21% of the total 1835812 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","233'235",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.04",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.04",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","168.13",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.42",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.41",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","222'560",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.20",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.02",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.90",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.41",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.04",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.69",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.59",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.94",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.49",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.49 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.14",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.10",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.24",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.44",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 109.1 cycles between issuing two instructions."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'164.26",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'285'876",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'333.46",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'341'374",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 507377 fused and 394394 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.07",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.95",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","922'309",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.23",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","342.99",
"77","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 397189 excessive sectors (21% of the total 1847999 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.65",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","234'527",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.16",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.16",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","169.76",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.41",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.50",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","225'758.77",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.82",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.67",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.93",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.97",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.50",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.16",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.76",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.60",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.14",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.44",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.44 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.50",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.45",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.23",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.42",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.8 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 108.5 cycles between issuing two instructions."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'409.01",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'366'156",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'578.14",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'421'631",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 514099 fused and 399706 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.66",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.75",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","934'691",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.23",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","347.82",
"78","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 401012 excessive sectors (21% of the total 1871269 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.73",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","236'599",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.08",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.08",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","169.92",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.42",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.44",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","226'655.72",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.49",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.99",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","262.16",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.44",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.08",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.78",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.51",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.04",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.49",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.49 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.23",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.17",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.23",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.42",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 109.2 cycles between issuing two instructions."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'499.74",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'395'916",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'668.74",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'451'346",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 516519 fused and 401646 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.82",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.84",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","939'291",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.23",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","349.65",
"79","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 402852 excessive sectors (21% of the total 1880754 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.72",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","239'650",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.91",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.91",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","172.19",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.42",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.35",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","228'680.84",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.19",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.67",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.01",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.0%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.0%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.51",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.35",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.91",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.97",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.54",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.94",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.49",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.49 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.11",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.05",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.22",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.41",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 109.1 cycles between issuing two instructions."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'668.77",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'451'356",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'837.89",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'506'829",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 521239 fused and 405346 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.98",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.91",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","947'831",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.23",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","352.94",
"80","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 406406 excessive sectors (21% of the total 1897593 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.71",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","239'530",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.02",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.02",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","172.38",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.41",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.42",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","229'530.76",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.47",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.67",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","83.94",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (83.9%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (83.9%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","261.15",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.42",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.02",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.99",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.55",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.03",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.48",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.48 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.99",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.92",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.22",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.41",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 109.0 cycles between issuing two instructions."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'725.24",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'469'880",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","19'894.23",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'525'309",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 522776 fused and 406566 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.77",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.81",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","950'690",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.23",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","354.06",
"81","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 408966 excessive sectors (21% of the total 1904917 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.66",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","239'377",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.12",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.12",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","173.18",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.46",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","230'538.77",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.07",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.15",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.65",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.46",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.12",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.22",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.63",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.23",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.49",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.49 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.03",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.96",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 109.0 cycles between issuing two instructions."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'852.68",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'511'680",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'021.69",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'567'114",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 526370 fused and 409370 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.53",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.69",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","957'124",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","356.52",
"82","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410261 excessive sectors (21% of the total 1915666 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","240'134",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.03",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.03",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","173.57",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.43",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.43",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","231'121.99",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.93",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.67",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.05",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.13",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.43",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.03",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.24",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.58",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.18",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.44",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.44 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.47",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.39",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.4 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.8% of the total average of 108.5 cycles between issuing two instructions."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'879.06",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'520'332",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'048.04",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'575'758",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 527076 fused and 409935 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.69",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.77",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","958'461",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","357.05",
"83","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410801 excessive sectors (21% of the total 1918843 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","239'648",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.01",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.01",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","172.83",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.39",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","230'425.94",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.93",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.13",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.50",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.39",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.01",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.50",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.25",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.18",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.46",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.46 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.80",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.72",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 108.8 cycles between issuing two instructions."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'841.52",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'508'020",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'010.52",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'563'451",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 525995 fused and 409100 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.52",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.69",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","956'569",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","356.34",
"84","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 410016 excessive sectors (21% of the total 1914596 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.66",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","240'662",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.05",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.05",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","174.11",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.39",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","231'769.34",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.07",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.15",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.05",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.39",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.05",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.56",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.33",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.23",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.45",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.45 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.57",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.49",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.2% of the total average of 108.6 cycles between issuing two instructions."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'953.12",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'544'624",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'122.12",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'600'056",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 529151 fused and 411559 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.78",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.82",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","962'202",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","358.49",
"85","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411653 excessive sectors (21% of the total 1924903 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","240'499",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.91",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.91",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","173.31",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.35",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","230'541.73",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.73",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.18",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","259.77",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.35",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.91",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.57",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.47",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.12",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.47",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.47 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.81",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.74",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.21",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.40",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.1% of the total average of 108.8 cycles between issuing two instructions."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'861.59",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'514'600",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'030.57",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'570'026",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 526545 fused and 409535 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.02",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.93",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","957'584",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","356.74",
"86","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411210 excessive sectors (21% of the total 1917045 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.68",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","240'972",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.12",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.12",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","173.95",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.40",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","232'209.28",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.16",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.18",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","261.28",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.40",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.12",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.54",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.35",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.26",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.46",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.46 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.81",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.73",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.2% of the total average of 108.8 cycles between issuing two instructions."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","19'997.29",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'559'112",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'166.27",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'614'537",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 530397 fused and 412531 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.71",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.78",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","964'432",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.24",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","359.35",
"87","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 411565 excessive sectors (21% of the total 1928348 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.65",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","242'726",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.08",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.08",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","175.74",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.46",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.42",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","233'411.35",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.04",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.25",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.06",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.42",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.08",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.40",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.45",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.22",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.46",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.46 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.69",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.61",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 108.7 cycles between issuing two instructions."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","20'107.65",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'595'308",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'276.63",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'650'735",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 533541 fused and 414972 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.50",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.68",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","969'999",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.25",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","361.46",
"88","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 415480 excessive sectors (21% of the total 1941115 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","244'778",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.92",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.92",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","176.77",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.47",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.34",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","233'876.89",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.59",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.69",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.31",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","259.33",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.34",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.92",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.38",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.41",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.07",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.46",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.46 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.71",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.62",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.20",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.39",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 108.7 cycles between issuing two instructions."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","20'160.06",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'612'500",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'329.06",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'667'931",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 535021 fused and 416126 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.92",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.88",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","972'645",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.25",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","362.48",
"89","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 416286 excessive sectors (21% of the total 1946409 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.70",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","247'084",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.12",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.12",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","177.98",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.43",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.48",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","238'285.76",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.13",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.10",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.1%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.1%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","261.84",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.48",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.12",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.04",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.72",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.25",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.68",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.32",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.48",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.48 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.17",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.07",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.18",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.37",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 109.2 cycles between issuing two instructions."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","20'466.24",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'712'928",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'635.23",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'768'354",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 543708 fused and 422884 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.61",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.73",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","988'096",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.26",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","368.37",
"90","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 421593 excessive sectors (21% of the total 1976630 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.66",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","247'715",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.10",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.10",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","179.20",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.48",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","238'235.29",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.07",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.26",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","260.61",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.48",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.10",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.11",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.65",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.23",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.50",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.50 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.22",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.12",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.18",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.37",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.9% of the total average of 109.2 cycles between issuing two instructions."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.4 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","20'499.54",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'723'848",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","20'668.51",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'779'270",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 544653 fused and 423619 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.92",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.88",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","989'776",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.26",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","369.01",
"91","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 423857 excessive sectors (21% of the total 1981534 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","257'477",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.81",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.81",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","185.95",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.46",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.33",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","244'492.52",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.18",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.67",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.41",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.4%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.4%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","258.27",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.33",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.81",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.98",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.82",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.94",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.52",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.52 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.30",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.18",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.16",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.34",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 46.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 42.7% of the total average of 109.3 cycles between issuing two instructions."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","21'037.29",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'900'232",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","21'206.28",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'955'660",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 559917 fused and 435491 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.20",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.02",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'016'912",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.28",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","379.35",
"92","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 435618 excessive sectors (21% of the total 2036591 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.70",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","259'125",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.73",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.73",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","186.66",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.45",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.29",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","245'624.45",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","79.96",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","WRN","Compute is more heavily utilized than Memory: Look at the Compute Workload Analysis section to see what the compute pipelines are spending their time doing. Also, consider whether any computation is redundant and could be reduced or moved to look-up tables."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 63% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.32",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","258.17",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.29",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.73",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","17.97",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","16.73",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","25.87",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.71",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.29",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.53",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.53 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.49",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.36",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.15",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.34",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.0% of the total average of 109.5 cycles between issuing two instructions."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.2 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","21'108.95",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","6'923'736",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","21'277.92",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","6'979'157",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 561951 fused and 437073 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.18",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.01",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'020'528",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.29",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","380.73",
"93","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 436883 excessive sectors (21% of the total 2043639 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.75",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.40",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","267'940",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.08",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.08",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","191.90",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.50",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.56",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","257'909.66",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.62",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.68",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.77",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","262.88",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.56",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.08",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.19",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.28",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.41",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.49",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.49 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.15",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.98",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.11",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.29",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.3% of the total average of 109.1 cycles between issuing two instructions."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","22'209.83",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","7'284'824",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","22'378.80",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","7'340'247",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 593199 fused and 461377 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.93",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.89",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'076'080",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.33",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","401.90",
"94","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 463450 excessive sectors (21% of the total 2158923 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.74",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","268'674",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","28.05",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","28.05",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","192.67",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.48",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.52",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","258'651.65",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.50",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.64",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.6%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.6%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","262.24",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.52",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","28.05",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.14",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.26",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.37",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.70",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.30",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.48",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.48 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","108.91",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","109.74",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.11",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.29",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.2 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.3% of the total average of 108.9 cycles between issuing two instructions."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","22'237.73",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","7'293'976",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","22'406.73",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","7'349'406",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 593991 fused and 461993 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","78.72",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","37.79",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'077'488",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.33",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","402.43",
"95","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 460063 excessive sectors (21% of the total 2157722 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.70",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","283'656",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.61",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.61",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","204.19",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.48",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.38",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","270'219.17",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","80.80",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.65",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.80",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","257.23",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.38",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.61",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.26",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.69",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.14",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.68",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.32",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.52",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.52 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.68",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.48",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.07",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.25",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.6 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.4% of the total average of 109.7 cycles between issuing two instructions."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","23'215.27",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","7'614'608",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","23'384.24",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","7'670'032",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 621738 fused and 483574 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.24",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.03",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'126'816",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.36",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","421.23",
"96","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 482859 excessive sectors (21% of the total 2259071 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.68",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","281'364",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.84",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.84",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","202.98",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.48",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.45",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","269'201.16",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.11",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.65",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","84.76",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (84.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (84.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","258.73",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.45",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.84",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.24",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","17.48",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.24",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.67",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.33",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.51",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.51 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","109.76",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","110.57",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.07",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.26",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 47.5 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 43.3% of the total average of 109.8 cycles between issuing two instructions."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.1 threads being active per cycle. This is further reduced to 18.3 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","23'121.10",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","7'583'720",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","23'290.08",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","7'639'146",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 619065 fused and 481495 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.28",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.05",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'122'064",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.35",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","419.42",
"97","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 481171 excessive sectors (21% of the total 2250126 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","310'921",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.52",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.52",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","224.13",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.51",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.46",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","297'988.90",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.69",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.64",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","85.21",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (85.2%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (85.2%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","256.02",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.46",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.52",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.65",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","18.52",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.43",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.68",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.32",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.60",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.60 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","110.65",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","111.38",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","18.99",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.17",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 48.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.0% of the total average of 110.7 cycles between issuing two instructions."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.0 threads being active per cycle. This is further reduced to 18.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","25'583.49",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","8'391'384",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","25'752.47",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","8'446'810",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 688959 fused and 535857 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.60",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.21",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'246'320",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.42",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","466.77",
"98","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 533650 excessive sectors (21% of the total 2501226 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.67",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.38",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","310'114",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.63",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.63",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","224.06",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.52",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.52",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","298'126.45",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.98",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 65% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.65",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","85.25",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (85.3%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (85.3%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","256.49",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.52",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.63",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.65",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","18.49",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.52",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.67",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.33",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.59",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.59 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","110.59",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","111.32",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","19.00",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.17",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 48.7 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.0% of the total average of 110.6 cycles between issuing two instructions."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 19.0 threads being active per cycle. This is further reduced to 18.2 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","25'605.68",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","8'398'664",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","25'774.66",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","8'454'088",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 689589 fused and 536347 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","79.67",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.24",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'247'440",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.42",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","467.20",
"99","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 536782 excessive sectors (21% of the total 2506653 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.72",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","341'166",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.11",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.11",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","245.18",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.58",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.34",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","323'309.37",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.36",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","85.83",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (85.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (85.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","252.94",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.34",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.11",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.79",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.16",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.32",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.68",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.68 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","111.39",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","112.07",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","18.92",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.10",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 50.0 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.8% of the total average of 111.4 cycles between issuing two instructions."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 18.9 threads being active per cycle. This is further reduced to 18.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","27'837.24",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","9'130'616",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","28'006.21",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","9'186'038",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 752931 fused and 585613 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","80.40",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.59",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'360'048",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.47",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","510.12",
"100","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 581548 excessive sectors (21% of the total 2727686 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Frequency","cycle/nsecond","9.69",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Frequency","cycle/nsecond","1.39",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Elapsed Cycles","cycle","341'187",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Memory Throughput","%","27.09",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","DRAM Throughput","%","27.09",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Duration","usecond","245.82",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L1/TEX Cache Throughput","%","13.58",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","L2 Cache Throughput","%","14.34",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","SM Active Cycles","cycle","323'405.02",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","GPU Speed Of Light Throughput","Compute (SM) Throughput","%","81.39",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight","","","","SOLBottleneck","INF","The kernel is utilizing greater than 80.0% of the available compute or memory performance of the device. To further improve performance, work will likely need to be shifted from the most utilized to another unit. Start by analyzing workloads in the Compute Workload Analysis section."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The ratio of peak float (fp32) to double (fp64) performance on this device is 64:1. The kernel achieved  close to 0% of this device's fp32 peak performance and 17% of its fp64 peak performance. If Compute Workload Analysis determines that this kernel is fp64 bound, consider using 32-bit precision floating point operations to improve its performance. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#roofline) for more details on roofline analysis."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SpeedOfLight_RooflineChart","","","","SOLFPRoofline","WRN","The achieved fp64 performance is 64% lower than the fp64 pipeline utilization. Check the Instruction Statistics section to see if using fused instructions can benefit this kernel."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Active","inst/cycle","0.34",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Executed Ipc Elapsed","inst/cycle","0.33",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issue Slots Busy","%","8.66",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","Issued Ipc Active","inst/cycle","0.35",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Compute Workload Analysis","SM Busy","%","85.84",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","ComputeWorkloadAnalysis","","","","HighPipeUtilization","WRN","FP64 is the highest-utilized pipeline (85.8%) based on active cycles, taking into account the rates of its different instructions. It executes 64-bit floating point operations. The pipeline is over-utilized and likely a performance bottleneck. Based on the number of executed instructions, the highest utilized pipeline (85.8%) is FP64 (FP64). It executes non-DMMA 64-bit floating point operations. Comparing the two, the overall pipeline utilization appears to be caused by frequent, low-latency instructions. See the Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-decoder) or hover over the pipeline name to understand the workloads handled by each pipeline. The Instruction Statistics section shows the mix of executed instructions in this kernel. Check the Warp State Statistics section for which reasons cause warps to stall."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Memory Throughput","Gbyte/second","252.16",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Busy","%","14.34",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Max Bandwidth","%","27.09",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L1/TEX Hit Rate","%","18.86",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Success Rate","%","0",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Compression Ratio","","0",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","L2 Hit Rate","%","19.10",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Memory Workload Analysis","Mem Pipes Busy","%","26.33",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for loads from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.6 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced loads and try to minimize how many cache lines need to be accessed per memory request."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","MemoryWorkloadAnalysis_Tables","","","","MemoryCacheAccessPattern","WRN","The memory access pattern for stores from L1TEX to L2 is not optimal. The granularity of an L1TEX request to L2 is a 128 byte cache line. That is 4 consecutive 32-byte sectors per L2 request. However, this kernel only accesses an average of 1.0 sectors out of the possible 4 sectors per cache line. Check the Source Counters section for uncoalesced stores and try to minimize how many cache lines need to be accessed per memory request."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","One or More Eligible","%","8.69",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Issued Warp Per Scheduler","","0.09",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","No Eligible","%","91.31",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Active Warps Per Scheduler","warp","9.67",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Scheduler Statistics","Eligible Warps Per Scheduler","warp","0.14",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SchedulerStats","","","","IssueSlotUtilization","WRN","Every scheduler is capable of issuing one instruction per cycle, but for this kernel each scheduler only issues an instruction every 11.5 cycles. This might leave hardware resources underutilized and may lead to less optimal performance. Out of the maximum of 12 warps per scheduler, this kernel allocates an average of 9.67 active warps per scheduler, but only an average of 0.14 warps were eligible per cycle. Eligible warps are the subset of active warps that are ready to issue their next instruction. Every cycle with no eligible warp results in no instruction being issued and the issue slot remains unused. To increase the number of eligible warps, avoid possible load imbalances due to highly different execution durations per warp. Reducing stalls indicated on the Warp State Statistics and Source Counters sections can help, too."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Issued Instruction","cycle","111.35",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Warp Cycles Per Executed Instruction","cycle","112.03",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Active Threads Per Warp","","18.92",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Warp State Statistics","Avg. Not Predicated Off Threads Per Warp","","18.10",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","WRN","On average, each warp of this kernel spends 49.9 cycles being stalled waiting for a scoreboard dependency on a MIO (memory input/output) operation (not to L1TEX). The primary reason for a high number of stalls due to short scoreboards is typically memory operations to shared memory. Other reasons include frequent execution of special math instructions (e.g. MUFU) or dynamic branching (e.g. BRX, JMX). Consult the Memory Workload Analysis section to verify if there are shared memory operations and reduce bank conflicts, if reported. Assigning frequently accessed values to variables can assist the compiler in using low-latency registers instead of direct memory accesses.. This stall type represents about 44.8% of the total average of 111.4 cycles between issuing two instructions."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","CPIStall","INF","Check the Warp Stall Sampling (All Cycles) table for the top stall locations in your source based on sampling data. The Kernel Profiling Guide (https://docs.nvidia.com/nsight-compute/ProfilingGuide/index.html#metrics-reference) provides more details on each stall reason."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","WarpStateStats","","","","ThreadDivergence","WRN","Instructions are executed in warps, which are groups of 32 threads. Optimal instruction throughput is achieved if all 32 threads of a warp execute the same instruction. The chosen launch configuration, early thread completion, and divergent flow control can significantly lower the number of active threads in a warp per cycle. This kernel achieves an average of 18.9 threads being active per cycle. This is further reduced to 18.1 threads per warp due to predication. The compiler may use predication to avoid an actual branch. Instead, all instructions are scheduled, but a per-thread condition code or predicate controls which threads execute the instructions. Try to avoid different execution paths within a warp when possible. In addition, ensure your kernel makes use of Independent Thread Scheduling, which allows a warp to reconverge after a data-dependent conditional block by explicitly calling __syncwarp()."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Executed Instructions Per Scheduler","inst","27'848.66",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Executed Instructions","inst","9'134'360",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Avg. Issued Instructions Per Scheduler","inst","28'017.64",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Instruction Statistics","Issued Instructions","inst","9'189'786",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","InstructionStats","","","","FPInstructions","WRN","This kernel executes 753255 fused and 585865 non-fused FP64 instructions. By converting pairs of non-fused instructions to their fused (https://docs.nvidia.com/cuda/floating-point/#cuda-and-floating-point), higher-throughput equivalent, the achieved FP64 performance could be increased by up to 22% (relative to its current performance). Check the Source page to identify where this kernel executes FP64 instructions."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Block Size","","672",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Function Cache Configuration","","CachePreferL1",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Grid Size","","1'024",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Registers Per Thread","register/thread","32",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Shared Memory Configuration Size","Kbyte","8.19",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Driver Shared Memory Per Block","Kbyte/block","1.02",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Dynamic Shared Memory Per Block","byte/block","0",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Static Shared Memory Per Block","byte/block","0",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Threads","thread","688'128",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Launch Statistics","Waves Per SM","","6.24",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit SM","block","16",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Registers","block","3",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Shared Mem","block","8",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Block Limit Warps","block","2",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Active Warps per SM","warp","42",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Theoretical Occupancy","%","87.50",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Occupancy","%","80.36",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","Achieved Active Warps Per SM","warp","38.57",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Occupancy","","","","Occupancy","WRN","This kernel's theoretical occupancy (87.5%) is limited by the number of warps within each block. See the CUDA Best Practices Guide (https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html#occupancy) for more details on optimizing occupancy."
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions Ratio","%","0.15",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Instructions","inst","1'360'624",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Branch Efficiency","%","79.47",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","Source Counters","Avg. Divergent Branches","","510.34",
"101","3171929","hpcg_bench","127.0.0.1","void amgx::multicolor_gauss_seidel_solver::multicolorGSSmoothCsrKernel_nPerRow<int, double, double, (int)672, (int)32, (int)32>(const T1 *, const T1 *, const T1 *, const T2 *, const T2 *, const T3 *, const T3 *, T3, const int *, int, int, T3 *)","1","15","(672, 1, 1)","(1024, 1, 1)","0","8.6","SourceCounters","","","","UncoalescedGlobalAccess","WRN","This kernel has uncoalesced global accesses resulting in a total of 582426 excessive sectors (21% of the total 2729435 sectors). Check the L2 Theoretical Sectors Global Excessive table for the primary source locations. The CUDA Programming Guide (https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory-accesses) had additional information on reducing uncoalesced device memory accesses."
